<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Go学习笔记1]]></title>
    <url>%2F2019%2F10%2F11%2FGo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[1.官网可下载windows一键安装程序 2.GOPATH目录约定有三个子目录src存放源代码(比如：.go .c .h .s等) 按照golang默认约定，go run，go install等命令的当前工作路径（即在此路径下执行上述命令）。pkg编译时生成的中间文件（比如：.a） golang编译包时bin编译后生成的可执行文件（为了方便，可以把此目录加入到 $PATH 变量中，如果有多个gopath，那么使用{GOPATH//://bin:}/bin添加所有的bin目录） 3.Go程序的基本结构和要素包的概念、导入与可见性包是结构化代码的一种方式：每个程序都由包(通常称为pkg的概念组成)，可以使用自身的包或者从其它包中导入内容。每个Go文件都属于且仅属于一个包。一个包可以由许多以.go为扩展名的源文件组成，你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个Go应用程序都包含一个名为main的包。所有的包名都应该使用小写字母。标准库：在Go的安装文件里包含了一些可以直接使用的包，即标准库。在windows下，标准库的位置在go/pkg/windows_386中；在 Linux 下，标准库在 Go 根目录下的子目录 pkg\linux_amd64 中（如果是安装的是 32 位，则在 linux_386 目录中）。一般情况下，标准包会存放在$GOROOT/pkg/$GOOS_$GOARCH/ 目录下。Go的标准库包含了大量的包，如fmt和os，但是你也可以创建自己的包。如果想要创建一个程序，则包和包内的文件都必须以正确的顺序进行编译。包的依赖关系决定了其构建顺序。属于同一个包的源文件必须全部被遗弃编译，一个包即是编译时的一个单元，因此根据惯例，每个目录都只包含一个包。 可见性规则：当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需先导入这个包），这被称为导出；标识符如果以小写字母开头，则包对外是不可兼得，但是他们在整个包的内部是可见并且可用的。因此，在导入一个外部包后，能够且只能够访问该包中导出的对象。 值类型和引用类型程序中所用到的内存在计算机中使用一堆箱子来表示，这些箱子被称为“字”。根据不同的处理器以及操作系统类型，所有的字都具有32位（4字节）或64位（8字节）的相同长度；所有的字都使用相关的内存地址来进行表示。所有像int、float、bool和string这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值： 另外，想数组和结构这些复合类型也是值类型。当使用等号将一个变量的值赋给另一个变量时，如j=i，实际上是在内存中将i的值进行了拷贝。更复杂的数据通常会需要使用多个字，这些数据一般使用引用类型保存。一个引用类型的变量r1存储的是r1的值所在的内存地址，或内存地址中第一个字所在的位置。这个内存地址被称之为指针，这个指针实际上也被存在另外的某一个字中。同一个引用类型的指针指向的多个字可以是在连续的内存地址中，这也是计算效率最高的一种存储方式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。当使用赋值语句r2=r1是，只有引用地址被复制。如果r1的值被改变了，那么这个值的所有引用都会指向被修改后的内容，在这个例子中，r2也会受到影响。在Go语言中，指针属于引用类型，其他的引用类型还包括slices，maps和channel。被引用的变量会被存储在堆中，以便进行垃圾回收，且比栈拥有更大的内存空间。]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式的使用]]></title>
    <url>%2F2018%2F12%2F12%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[正则表达式正则表达式在爬虫中被广泛使用，正则和Xpath各有各的优点。虽然以前学习过正则表达式，但现在还总是迷迷糊糊的，今天有所顿悟。 re.search()和re.match()re.match决定RE是否在字符串刚开始的位置匹配。//注：这个方法并不是完全匹配。当pattern结束时若string还有剩余字符，仍然视为成功。想要完全匹配，可以在表达式末尾加上边界匹配符’$’ re.search函数会在字符串内查找模式匹配,只要找到第一个匹配然后返回，如果字符串没有匹配，则返回None。 match和search一旦匹配成功，就是一个match object对象，而match object对象有以下方法： group() 返回被RE匹配的字符串 start() 返回匹配开始的位置编号 end() 返回匹配结束的位置编号 span() 返回一个元组包含匹配（开始，结束）的位置编号 group() 返回re整体匹配的字符串，可以一次输入多个组号，对应组号匹配的字符串 re.search()后使用group()不加参数表示返回被匹配的整体字符串，group()加上一个参数1表示取出匹配的第一组字符，可以输入多个组号。 eg.: 12345import restr1 = '&lt;h1&gt;hello world&lt;/h1&gt;你好世界&lt;/h1&gt;'x = re.search('&lt;h1&gt;(.*?)&lt;/h1&gt;(.*?)&lt;/h1&gt;', str1).group(1,2)print(x)结果：('hello world', '你好世界') re.compile和re.findallre.compile是对正则表达式进行预编译，返回一个对象的模式，主要作用是把常用的正则表达式编译成正则表达式对象，这样可以提高一点效率。 格式：re.compile(pattern,flags=0) pattern：编译时用的表达式字符串 flags：编译标志位，用于修改正则表达式的匹配方式，模式修正符。 常用的flags模式修正符有： re.S：使.匹配包括换行符在内的所有字符 re.I：使匹配不区分大小写 re.L：做本地化识别匹配 re.M：多行匹配，影响^和$ re.X：该标志通过给予更灵活的格式一遍将正则表达式写的更易于理解 re.U：根据Unicode字符集解析字符，这个标志影响\w,\W,\b,\B re.findall遍历匹配，可以获取字符串中所有匹配的字符串，返回一个列表。 格式：re.findall(pattern, string, flags=0) pattern为表达式字符串， strings为要匹配的字符串 flags为模式修正符 所以可以看到： 在findall中包含了compile，为了简洁，一般我都不适用compile。 re.finditerre.finditer() 搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器。找到 RE 匹配的所有子串，并把它们作为一个迭代器返回。 格式和findall()一样，返回的是一个迭代器，要使用for循环迭代取值，由于他返回的是一个Match对象，所以还要使用.group()函数来取出字符串。 re.split按照能够匹配的子串将string分割后返回列表。 可以使用re.split来分割字符串，如：re.split(r’\s+’, text)；将字符串按空格分割成一个单词列表。 格式： re.split(pattern, string[, maxsplit]) maxsplit用于指定最大分割次数，不指定将全部分割。 eg. 123print(re.split('\d+','one1two2three3four4five5'))执行结果如下：['one', 'two', 'three', 'four', 'five', ''] re.supre.sup使用re替换string中每一个匹配的子串后返回替换后的字符串。 eg. 1re.sup(&apos;[\n ]&apos;, &apos;&apos;, str) 上面这个例子会吧str中所有的换行符和空格去除。 一些要注意的地方re.match与re.search与re.findall的区别： re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。 12345678910a=re.search('[\d]',"abc33").group()print(a)p=re.match('[\d]',"abc33")print(p)b=re.findall('[\d]',"abc33")print(b)执行结果：3None['3', '3'] 贪婪匹配与非贪婪匹配 ?,+?,??,{m,n}? 前面的,+,?等都是贪婪匹配，也就是尽可能匹配，后面加?号使其变成惰性匹配 12345678910111213141516171819202122232425a = re.findall(r"a(\d+?)",'a23b')print(a)b = re.findall(r"a(\d+)",'a23b')print(b)执行结果：['2']['23']a = re.match('&lt;(.*)&gt;','&lt;H1&gt;title&lt;H1&gt;').group()print(a)b = re.match('&lt;(.*?)&gt;','&lt;H1&gt;title&lt;H1&gt;').group()print(b)执行结果：&lt;H1&gt;title&lt;H1&gt;&lt;H1&gt;a = re.findall(r"a(\d+)b",'a3333b')print(a)b = re.findall(r"a(\d+?)b",'a3333b')print(b)执行结果如下：['3333']['3333']#######################这里需要注意的是如果前后均有限定条件的时候，就不存在什么贪婪模式了，非匹配模式失效。 本篇博客借鉴CNBLOGS]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL语法]]></title>
    <url>%2F2018%2F11%2F12%2FSQL%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[SQL语句对数据库进行操作，我们主要使用的是SQL语句。SQL语句包括最基本的增删改查和高级功能比如各种约束、高级查询等。 创建数据库、表CREATE DATABASE 数据库名 用来创建数据库 CREATE TABLE 表名(字段1 定义类型(长度),字段2 定义类型(长度)) eg.：创建学生库，学生表，有id和name两个字段，类型都为varchar，长度为20，id为主键 12CREATE DATABASE studentsCREATE TABLE students(id VARCHAR(20) PRIMARY KEY,name VARCHAR(20)) 增删改查查询语句：SELECT 字段 FROM 表名 比如从学生表中查询所有学生信息： SELECT * FROM students 在python中，查询语句执行完成后需要使用fetchall或者fetchone来接收这个查询结果，fetchall返回所有数据，fetchone返回一条数据。eg： cursor.excute(“SELECT * FROM students”) data = cursor.fetchall() 这两句话也可以合成一句话： data = cursor.excute(‘SELECT * FROM students’).fetchall() 返回的数据类型是列表嵌套元组形式，可以通过下标访问取值。 SQL SELECT DISTINCT在表中，可能会包含重复值。有时，我们只需要列出不同的值。这是可以使用 SELECT DISTINCT语句。 eg：查询学生表中所有不同的行。 1SELECT DISTINCT * FROM students WHERE 语句如果需要有条件的从表中选取数据，可将WHERE子句添加到SELECT语句： 1SELECT 列名称 FROM 表名称 WHERE 列 运算符 值 下面这些运算符可以在WHERE子句中使用。 操作符 描述 = 等于 &lt;&gt; 不等于 &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 BETWEEN 在某个范围内 LIKE 搜索某种模式 注释：在某些版本的 SQL 中，操作符 &lt;&gt; 可以写为 !=。 eg：假如学生列表中有id、年龄、姓名和性别列。我们希望选择性别为男的所有行 1SELECT * FROM students WHERE sex='男' eg:选择所有年龄&gt;10的学生 1SELECT * FROM students WHERE age&gt;10 这里需要提醒一下：当字段值为数字型时，不要使用引号，是字符串是，要使用引号，尽量都使用单引号！和我们学习python的str和int规则一样。 SQL AND&amp;OR 运算符AND和OR运算符用于一个以上的条件对记录进行过滤。 AND和OR可在WHERE子语句中把两个或多个条件结合起来。 如果第一个条件和第二个条件都成立，则AND运算符显示一条记录 如果第一个和第二个条件只要有一个城里，则OR运算符显示一条记录。 AND eg：选择id为1并且name为m4a1的人 1SELECT * FROM students WHERE id=1 AND name='m4a1' OR eg：选择id为1或者name为m4a1的人 1SELECT * FROM students WHERE id=1 OR name='m4a1' AND和OR也可以结合起来组成复杂的表达式： eg：选择id为1或者name为m4a1并且age=10的人 1SELECT * FROM students WHERE (id=1 OR name='m4a1')AND age=10 SQL ORDER BY 语句有时候我们需要对查询返回结果进行排序，在MongoDB中有sort方法，那么在SQL中使用什么呢？ 答案是使用ORDER BY。 ORDER BY语句用于根据指定的列对结果进行排序，默认按照升序进行排序；如果希望按照降序排序，可以使用DESC关键字。 eg：查询所有学生行并以id顺序排序 123SELECT * FROM students ORDER BY id#降序排列可以添加DESC关键字SELECT * FROM students ORDER BY id DESC 增加INSERT INTO 表名(列名1,列名2) VALUES(‘值1’,’值2’) 比如在学生列表中添加一条记录 1INSERT INTO student(id,name) VALUES (1,'aK47') 修改修改使用的是update语句： UPDATE 表名 SET 列名 = 新值 WHERE 列名称 = 某值 列的概念： eg:将学生表中id为1的name改为m4a1 12UPDATE students SET name = 'm4a1' WHERE id = 1UPDATE students SET name = 'scar',id=2 WHERE id = 1#修改多列注意使用,号分割 删除DELETE语句用于删除表中的行： DELETE FROM 表名称 WHERE 列名称 = 值 eg:删除student表id为1的那一行 1DELETE FROM student WHERE id = 1 删除所有行 123DELETE FROM student#或者DELETE * FROM student 高级语法SQL TopTOP子句用于规定要返回的记录的数目。对于拥有很多条记录的大型表来说，TOP子句是非常有用的。 MySQL中的top语法:从学生表中返回10条信息 1SELECT * FROM student LIMIT 10 eg：从students表中选取前两条记录 1SELECT TOP 2 * FROM students eg：从students表中选取50%的记录 1SELECT TOP 50 PERCENT * FROM students SQL LIKELIKE操作符用于在WHERE字句中搜索列中的指定模式。有点像是使用正则筛选数据 eg：我们希望从学生表中选取name以X开始的人： 12SELECT * FROM students WHERE name LIKE 'X%'#%号用于定义通配符（模式中缺少的字母） eg：从学生表中选取name以X结尾的人 1SELECT * FROM students WHERE neme LIKE '%X' eg：从学生表中选取name包含x的人 1SELECT * FROM students WHERE name LIKE '%X%' eg:使用NOT关键字，可以从学生表中选择name不包含x的人 1SELECT * FROM students WHERE name NOT LIKE '%X%' SQL通配符就像是正则表达式的匹配符，在搜索数据库中的数据时，SQL通配符可以替代一个或者多个字符。SQL通配符必须与LIKE运算符一起使用。 在SQL中，可以使用以下通配符： 通配符 描述 % 替代一个或多个字符 _ 仅替代一个字符 [charlist] 字符列中的任何单一字符 [^charlist]或者[!charlist] 不在字符列中的任何单一字符 eg：从学生表中选择name以A或B或C开头的人 1SELECT * FROM students WHERE name LIKE '[ABC]%' eg：从学生表中选择name不以A或B或C开头的人 1SELECT * FROM students WHERE name LIKE '[!ABC]%' SQL IN 操作符IN操作符允许我们在WHERE字句中规定多个值 语法： SELECT * FROM 表名 WHERE 列名 IN (value1,value2,…) eg:从students表中选取name为ak和m4的人 1SELECT * FROM students WHERE name IN ('ak','m4') SQL BETWEEN 操作符BETWEEN 操作符在WHERE子句中使用，作用是选取介于两个值之间的数据范围。这些值可以是数值、文本或者日期。 语法： SELECT * FROM 表名 WHERE 列名 BETWEEN value1 AND value2 eg：从students表中选择id介于5和10之间的人： 1SELECT * FROM students WHERE id BETWEEN 5 AND 10 注意：返回的结果包括5但不包括10 eg：如果要选择上面范围之外的人，可以使用NOT操作符 1SELECT * FROM students WHERE id NOT BETWENN 5 AND 10 SQL Alias（别名）通过使用SQL，可以为列名称和表名称指定别名。 语法：表的别名 1SELECT * FROM 表名 AS 别名 列的别名 1SELECT 列名 AS 别名 FROM 表名 SQL JOINSQL join用于根据两个或多个表中的列之间的关系，从这些表中查询数据。 join和key：有时为了得到完成的结果，我们需要从两个或更多的表中获取结果。我们就需要执行join。 数据库中的表可通过键将彼此联系起来。主键是一个列，在这个列中每一行都是唯一的。在表中，每个主键的值都是唯一的。这样做的目的是在不重复每个表中的所有数据的情况下，把表间的数据交叉捆绑在一起。 请看 “Persons” 表： Id_P LastName FirstName Address City 1 Adams John Oxford Street London 2 Bush George Fifth Avenue New York 3 Carter Thomas Changan Street Beijing 请注意，”Id_P” 列是 Persons 表中的的主键。这意味着没有两行能够拥有相同的 Id_P。即使两个人的姓名完全相同，Id_P 也可以区分他们。 接下来请看 “Orders” 表： Id_O OrderNo Id_P 1 77895 3 2 44678 3 3 22456 1 4 24562 1 5 34764 65 请注意，”Id_O” 列是 Orders 表中的的主键，同时，”Orders” 表中的 “Id_P” 列用于引用 “Persons” 表中的人，而无需使用他们的确切姓名。 请留意，”Id_P” 列把上面的两个表联系了起来。 引用两个表：我们可以通过引用两个表的方式，从两个表中获取数据： eg：上面两张表，加入person是客户表，order是订单表，我们需要查询哪个客户订购了什么： 1SELECT Persons.Lastname,Persons.FirstName,Orders.OrderNo FROM Persons,Orders WHERE Persons.ID_P = Orders.ID_P 结果： LastName FirstName OrderNo Adams John 22456 Adams John 24562 Carter Thomas 77895 Carter Thomas 44678 除了上面的方法，我们也可以使用关键字JOIN来从两个表中获取数据。 如果我们希望列出所有客户的订单，可以使用下面的语句： 1SELECT Persons.LastName,Persons.FirstName,Orders.OrderNo FROM Persons INNER JOIN Orders IN Persons.ID_P ORDER BY Persons.LastName 不同的SQL JOIN:除了我们在上面的例子中实用的INNER JOIN(内连接)，我们还可以使用其他几种链接。 下面列出了您可以使用的 JOIN 类型，以及它们之间的差异。 JOIN: 如果表中有至少一个匹配，则返回行 LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行 RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行 FULL JOIN: 只要其中一个表中存在匹配，就返回行 INNER JOIN在表中存在至少一个匹配时，INNER JOIN关键字返回行 语法： 1SELECT 列名1，列名2 FROM 表名1 INNER JOIN 表名2 ON 表名1.列名1=表名2.列名2 注释：INNER JOIN 和 JOIN 是相同的，SELECT 后面的列名可以是多个来自不同两张表的列名。 LEFT JOINLEFT JOIN 关键字会从左表（表1）那里返回所有航，即使在右表（表2）中没有匹配的行。 语法： 1SELECT 列名1，列名2 FROM 表名1 LEFT JOIN 表名2 ON 表名1.列名1=表名2.列名2 RIGHT JOINRIGHT JOIN 关键字会右表 (table_name2) 那里返回所有的行，即使在左表 (table_name1) 中没有匹配的行。 语法和LEFT JOIN 等一样。 FULL JOIN只要某个表中存在匹配，FULL JOIN 关键字就会返回行。 1234SELECT column_name(s)FROM table_name1FULL JOIN table_name2 ON table_name1.column_name=table_name2.column_name 注释：在某些数据库中， FULL JOIN 称为 FULL OUTER JOIN。 SQL UNION 和 UNION ALL 操作符SQL UNION操作符用于合并两个或多个SELECT语句的结果集。 请注意，UNION内部的SELECT语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条SELECT语句中的列的顺序必须相同。 语法： 123SELECT 列名 FROM 表1UNIONSELECT 列名 FROM 表2 注释：默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。 SQL UNION ALL语法： 123SELECT column_name(s) FROM table_name1UNION ALLSELECT column_name(s) FROM table_name2 复习时请看：W3SCHOOL SELECT INTOSELECT INTO 语句可用于创建表的备份文件。 SELECT INTO 语句从一个表中选取数据，然后把数据插入另一个表中。 SELECT INTO 语句常用于创建表的备份复件或者用于对记录进行存档。 语法：把所有列插入新表： 1SELECT * INTO new_table_name[IN externaldatabase] FROM old_table_name 或者只把希望的列插入新表： 123SELECT column_name(s)INTO new_table_name [IN externaldatabase] FROM old_tablename eg：制作Persons表的备份 1SELECT * INTO Persons_copy FROM Persons IN子句可以用于向另一个数据库表中拷贝表： 1SELECT * INTO Persons IN 'backup.mdb' FROM 如果我们希望拷贝某些列，可以在 SELECT 语句后列出这些域： 123SELECT LastName,FirstNameINTO Persons_backupFROM Persons SQL SELECT INTO实例-带有WHERE子句 我们也可以添加 WHERE 子句。 下面的例子通过从 “Persons” 表中提取居住在 “Beijing” 的人的信息，创建了一个带有两个列的名为 “Persons_backup” 的表： 1234SELECT LastName,FirstnameINTO Persons_backupFROM PersonsWHERE City='Beijing' SQL SELECT INTO 实例-被连接的表 从一个以上的白哦中选取数据也是可以做到的。 下面的例子会创建一个名为 “Persons_Order_Backup” 的新表，其中包含了从 Persons 和 Orders 两个表中取得的信息： 12345SELECT Persons.LastName,Orders.OrderNoINTO Persons_Order_BackupFROM PersonsINNER JOIN OrdersON Persons.Id_P=Orders.Id_P SQL CTEATE DATABASECREATE DATABASE用于创建数据库。 语法： 1CREATE DATABASE 数据库名 SQL CREATE TABLECREATE TABLE 用于创建数据库中的表 语法： 1CREATE TABLE 表名(字段1 数据类型，字段2 数据类型，字段3 数据类型，...) 数据类型（data_type）规定了列可容纳何种数据类型。下面的表格包含了SQL中最常用的数据类型： 数据类型 描述 integer(size)int(size)smallint(size)tinyint(size) 仅容纳整数。在括号内规定数字的最大位数。 decimal(size,d)numeric(size,d) 容纳带有小数的数字。”size” 规定数字的最大位数。”d” 规定小数点右侧的最大位数。 char(size) 容纳固定长度的字符串（可容纳字母、数字以及特殊字符）。在括号中规定字符串的长度。 varchar(size) 容纳可变长度的字符串（可容纳字母、数字以及特殊的字符）。在括号中规定字符串的最大长度。 date(yyyymmdd) 容纳日期。 SQL 约束约束用于限制加入表的数据的类型。 可以在创建表示规定约束（通过CREATE TABLE语句），或者在表创建之后通过（ALERT TABLE语句） 我们将主要探讨以下几种约束： NOT NULL UNIQUE PRIMARY KEY FOREIGN KEY CHECK DEFAULT NOT NULL(非空约束)NOT NULL 约束强制列不接受 NULL 值。 NOT NULL 约束强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或者更新记录。 eg：创建students表，有3个字段（id,name,sex）并且id，name添加非空约束 1CREATE TABLE students(id INT NOT NULL,name VARCHAR(30) NOT NULL,sex VARCHAR(10) ) UNIQUE(唯一约束)UNIQUE约束唯一标识数据库中的每条记录。 UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证，PRIMARY KEY 拥有自动定义的UNIQUE约束。每张表只能有一个PRIMARY KEY约束，但可以有多个UNIQUE约束。 下面的 SQL 在 “Persons” 表创建时在 “Id_P” 列创建 UNIQUE 约束： 123456789CREATE TABLE Persons(Id_P int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),UNIQUE (Id_P)) 如果需要命名 UNIQUE 约束，以及为多个列定义 UNIQUE 约束，请使用下面的 SQL 语法： 123456789CREATE TABLE Persons(Id_P int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),CONSTRAINT uc_PersonID UNIQUE (Id_P,LastName)) 当表已被创建时，如需在 “Id_P” 列创建 UNIQUE 约束，请使用下列 SQL： 12ALTER TABLE PersonsADD UNIQUE (Id_P) 如需命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束，请使用下面的 SQL 语法： 12ALTER TABLE PersonsADD CONSTRAINT uc_PersonID UNIQUE (Id_P,LastName) 如果需要撤销UNIQUE约束，使用下面的SQL 1ALTER TABLE Persons DROP INDEX 列名 SQL PRIMARY KEY (主键约束)PRIMARY KEY 约束唯一标识数据库表中的每条记录。 主键必须包含唯一的值。 主键列不能包含 NULL 值。 每个表都应该有一个主键，并且每个表只能有一个主键。 再创建表的时候定义主键约束eg： 123456789CREATE TABLE Persons(Id_P int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),PRIMARY KEY (Id_P)) 如果需要命名 PRIMARY KEY 约束，以及为多个列定义 PRIMARY KEY 约束，请使用下面的 SQL 语法： 123456789CREATE TABLE Persons(Id_P int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),CONSTRAINT pk_PersonID PRIMARY KEY (Id_P,LastName)) 如果在表已存在的情况下为 “Id_P” 列创建 PRIMARY KEY 约束，请使用下面的 SQL： 12ALTER TABLE PersonsADD PRIMARY KEY (Id_P) 如果需要命名 PRIMARY KEY 约束，以及为多个列定义 PRIMARY KEY 约束，请使用下面的 SQL 语法： 12ALTER TABLE PersonsADD CONSTRAINT pk_PersonID PRIMARY KEY (Id_P,LastName) 注释：如果您使用 ALTER TABLE 语句添加主键，必须把主键列声明为不包含 NULL 值（在表首次创建时）。 如需撤销 PRIMARY KEY 约束，请使用下面的 SQL： 12ALTER TABLE PersonsDROP PRIMARY KEY FOREIGN KEY(外键约束)一个表中的FOREIGN KEY指向另一个表中的PRIMARY KEY。 让我们通过一个例子来解释外键。请看下面两个表： “Persons” 表： Id_P LastName FirstName Address City 1 Adams John Oxford Street London 2 Bush George Fifth Avenue New York 3 Carter Thomas Changan Street Beijing “Orders” 表： Id_O OrderNo Id_P 1 77895 3 2 44678 3 3 22456 1 4 24562 1 请注意，”Orders” 中的 “Id_P” 列指向 “Persons” 表中的 “Id_P” 列。 “Persons” 表中的 “Id_P” 列是 “Persons” 表中的 PRIMARY KEY。 “Orders” 表中的 “Id_P” 列是 “Orders” 表中的 FOREIGN KEY。 FOREIGN KEY 约束用于预防破坏表之间连接的动作。 FOREIGN KEY 约束也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。 eg:下面的 SQL 在 “Orders” 表创建时为 “Id_P” 列创建 FOREIGN KEY： 12345678CREATE TABLE Orders(Id_O int NOT NULL,OrderNo int NOT NULL,Id_P int,PRIMARY KEY (Id_O),FOREIGN KEY (Id_P) REFERENCES Persons(Id_P)) FOREIGN KEY (列名) REFERENCES 表名(列名) 一个表中的外键是指向另一个表中的主键。 如果需要命名 FOREIGN KEY 约束，以及为多个列定义 FOREIGN KEY 约束，请使用下面的 SQL 语法： 123456789CREATE TABLE Orders(Id_O int NOT NULL,OrderNo int NOT NULL,Id_P int,PRIMARY KEY (Id_O),CONSTRAINT fk_PerOrders FOREIGN KEY (Id_P)REFERENCES Persons(Id_P)) 如果在 “Orders” 表已存在的情况下为 “Id_P” 列创建 FOREIGN KEY 约束，请使用下面的 SQL： 123ALTER TABLE OrdersADD FOREIGN KEY (Id_P)REFERENCES Persons(Id_P) 如果需要命名 FOREIGN KEY 约束，以及为多个列定义 FOREIGN KEY 约束，请使用下面的 SQL 语法： 1234ALTER TABLE OrdersADD CONSTRAINT fk_PerOrdersFOREIGN KEY (Id_P)REFERENCES Persons(Id_P) 如需撤销 FOREIGN KEY 约束，请使用下面的 SQL： 1ALTER TABLE Orders DROP FORENGN KEY fk_perOrders CHECK(范围约束)CHECK约束用于限制列中的值的范围。 如果对单个列定义CHECK约束，那么该列只允许特定的值。 如果对一个表定义CHECK约束，那么此约束会在特定的乐众对值进行限制。 eg：下面的 SQL 在 “Persons” 表创建时为 “Id_P” 列创建 CHECK 约束。CHECK 约束规定 “Id_P” 列必须只包含大于 0 的整数。 123456789CREATE TABLE Persons(Id_P int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),CHECK (Id_P&gt;0)) 如果需要命名 CHECK 约束，以及为多个列定义 CHECK 约束，请使用下面的 SQL 语法： 123456789CREATE TABLE Persons(Id_P int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),CONSTRAINT chk_Person CHECK (Id_P&gt;0 AND City='Sandnes')) 如果在表已存在的情况下为 “Id_P” 列创建 CHECK 约束，请使用下面的 SQL： 12ALTER TABLE PersonsADD CHECK (Id_P&gt;0) 如果需要命名 CHECK 约束，以及为多个列定义 CHECK 约束，请使用下面的 SQL 语法： 12ALTER TABLE PersonsADD CONSTRAINT chk_Person CHECK (Id_P&gt;0 AND City='Sandnes') 如需撤销 CHECK 约束，请使用下面的 SQL： 12ALTER TABLE PersonsDROP CHECK chk_Person DEFAULT(默认值约束)DEFAULT 约束用于向列中插入默认值。 如果没有规定其他的值，那么会将默认值添加到所有的新记录。 下面的 SQL 在 “Persons” 表创建时为 “City” 列创建 DEFAULT 约束： 12345678CREATE TABLE Persons(Id_P int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255) DEFAULT 'Sandnes') 通过使用类似 GETDATE() 这样的函数，DEFAULT 约束也可以用于插入系统值： 1234567CREATE TABLE Orders(Id_O int NOT NULL,OrderNo int NOT NULL,Id_P int,OrderDate date DEFAULT GETDATE()) 如果在表已存在的情况下为 “City” 列创建 DEFAULT 约束，请使用下面的 SQL： 12ALTER TABLE PersonsALTER City SET DEFAULT 'SANDNES' 如需撤销 DEFAULT 约束，请使用下面的 SQL： 12ALTER TABLE PersonsALTER City DROP DEFAULT SQL CREATE INDEX 语句CREATE INDEX 语句用于在表中创建索引。在不读取整个表的情况下，索引使数据库应用程序可以更快的查找数据。 您可以在表中创建索引，以便更加快速高效地查询数据。 用户无法看到索引，它们只能被用来加速搜索/查询。 注释：更新一个包含索引的表需要比更新一个没有索引的表更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。 语法： 1CREATE INDEX index_name ON table_name(column_name) 注释：”column_name” 规定需要索引的列。 SQL CREATE UNIQUE INDEX 语法: 在表上创建一个唯一的索引。唯一的索引意味着两个行不能拥有相同的索引值。 12CREATE UNIQUE INDEX index_nameON table_name (column_name) CREATE INDEX 实例 本例会创建一个简单的索引，名为 “PersonIndex”，在 Person 表的 LastName 列： 12CREATE INDEX PersonIndexON Person (LastName) 如果您希望以降序索引某个列中的值，您可以在列名称之后添加保留字 DESC： 12CREATE INDEX PersonIndexON Person (LastName DESC) 假如您希望索引不止一个列，您可以在括号中列出这些列的名称，用逗号隔开： 12CREATE INDEX PersonIndexON Person (LastName, FirstName) SQL 撤销索引、表以及数据库通过使用DROP语句，可以轻松地删除索引、表和数据库。 我们可以使用DROP INDEX命令删除表格中的索引。语法： 1ALTER TABLE table_name DROP INDEX index_name DROP TABLE 语句用于删除表（表的结构、属性以及索引也会被删除）： 1DROP TABLE 表名称 DROP DATABASE 语句用于删除数据库： 1DROP DATABASE 数据库名称 如果我们仅仅需要除去表内的数据，但并不删除表本身，那么我们该如何做呢？ 请使用 TRUNCATE TABLE 命令（仅仅删除表格中的数据）： 1TRUNCATE TABLE 表名称 SQL ALTER TABLE(修改表)ALTER TABLE 语句用于在已有的表中添加、修改或删除列。 添加列如果需要在表中添加列，请使用下列语法： 1ALTER TABLE 表名 ADD 列名 数据类型 也可以在添加列时给定一个默认值 1ALTER TABLE 表名 ADD 列名 数据类型 DEFAULT 'test' 要删除表中的列，请使用下列语法： 12ALTER TABLE 表名 DROP COLUMN 列名 注释：某些数据库系统不允许这种在数据库表中删除列的方式 (DROP COLUMN column_name)。 要改变表中列的数据类型，请使用下列语法： 12ALTER TABLE table_nameALTER COLUMN column_name datatype Persons 表: Id LastName FirstName Address City 1 Adams John Oxford Street London 2 Bush George Fifth Avenue New York 3 Carter Thomas Changan Street Beijing SQL ALTER TABLE 实例现在，我们希望在表 “Persons” 中添加一个名为 “Birthday” 的新列。 我们使用下列 SQL 语句： 12ALTER TABLE PersonsADD Birthday date 请注意，新列 “Birthday” 的类型是 date，可以存放日期。数据类型规定列中可以存放的数据的类型。 新的 “Persons” 表类似这样： Id LastName FirstName Address City Birthday 1 Adams John Oxford Street London 2 Bush George Fifth Avenue New York 3 Carter Thomas Changan Street Beijing 改变数据类型实例现在我们希望改变 “Persons” 表中 “Birthday” 列的数据类型。 我们使用下列 SQL 语句： 12ALTER TABLE PersonsALTER COLUMN Birthday year 请注意，”Birthday” 列的数据类型是 year，可以存放 2 位或 4 位格式的年份。 DROP COLUMN 实例接下来，我们删除 “Person” 表中的 “Birthday” 列： 12ALTER TABLE PersonDROP COLUMN Birthday Persons 表会成为这样: Id LastName FirstName Address City 1 Adams John Oxford Street London 2 Bush George Fifth Avenue New York 3 Carter Thomas Changan Street Beijing SQL AUTO INCREMENT 字段AUTO INCREMENT 会在新记录插入表中时生成一个唯一的数字。 我们通常希望在每次插入新记录时，自动的创建主键字段的值。 我们可以在表中创建一个auto-increment 字段。 eg：下列 SQL 语句把 “Persons” 表中的 “P_Id” 列定义为 auto-increment 主键： 123456789CREATE TABLE Persons(P_Id int NOT NULL AUTO_INCREMENT,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),PRIMARY KEY (P_Id)) MySQL 使用 AUTO_INCREMENT 关键字来执行 auto-increment 任务。 默认地，AUTO_INCREMENT 的开始值是 1，每条新记录递增 1。 要让 AUTO_INCREMENT 序列以其他的值起始，请使用下列 SQL 语法： 1ALTER TABLE Persons AUTO_INCREMENT=100 要在 “Persons” 表中插入新记录，我们不必为 “P_Id” 列规定值（会自动添加一个唯一的值）： 12INSERT INTO Persons (FirstName,LastName)VALUES (&apos;Bill&apos;,&apos;Gates&apos;) 上面的 SQL 语句会在 “Persons” 表中插入一条新记录。”P_Id” 会被赋予一个唯一的值。”FirstName” 会被设置为 “Bill”，”LastName” 列会被设置为 “Gates”。 SQL VIEW（视图）视图是可视化的表。 在SQL中，视图是基于SQL语句的结果集的可视化的表。 就像是通过基于某些条件创建了一张新表，这张新表保存在数据库的view子目录下 视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的表的真实字段。我们可以向视图添加SQL函数、WHERE以及JOIN语句，我们也可以提交数据，就像这些来自于某个单一的表。数据库的设计和结构不会受到视图中的函数、where或join语句的影响。 SQL CREATE VIEW 语法12CREATE VIEW view_name AS SELECT column_name(s) FROM table_name WHERE condition 视图总是显示最近的数据。每当用户查询视图是，数据库引擎通过使用SQL语句来重建数据。 实例：可以从某个查询内部、某个存储过程内部，或者从另一个视图内部来使用视图。通过向视图添加函数、join等等，我们可以向用户精确的提交我们希望提交的数据。 样本数据库Northwind 拥有一些被默认安装的视图。视图 “Current Product List” 会从 Products 表列出所有正在使用的产品。这个视图使用下列 SQL 创建： 1234CREATE VIEW [Current Product List] ASSELECT ProductID,ProductNameFROM ProductsWHERE Discontinued=No 我们可以查询上面这个视图： 1SELECT * FROM [Current Prodect List] Northwind 样本数据库的另一个视图会选取 Products 表中所有单位价格高于平均单位价格的产品： 1234CREATE VIEW [Products Above Average Price] ASSELECT ProductName,UnitPriceFROM ProductsWHERE UnitPrice&gt;(SELECT AVG(UnitPrice) FROM Products) 我们可以像这样查询上面这个视图： 1SELECT * FROM [Products Above Average Price] 另一个来自 Northwind 数据库的视图实例会计算在 1997 年每个种类的销售总数。请注意，这个视图会从另一个名为 “Product Sales for 1997” 的视图那里选取数据： 1234CREATE VIEW [Category Sales For 1997] ASSELECT DISTINCT CategoryName,Sum(ProductSales) AS CategorySalesFROM [Product Sales for 1997]GROUP BY CategoryName 我们可以像这样查询上面这个视图： 1SELECT * FROM [Category Sales For 1997] 我们也可以向查询添加条件。现在，我们仅仅需要查看 “Beverages” 类的全部销量： 12SELECT * FROM [Category Sales For 1997]WHERE CategoryName='Beverages' 语法讲解：CREATE VIEW 创建视图 AS 根据条件 上面的条件是从Products表中查询ProductID,ProductName字段其实就是一个SQL查询语句，这个AS后面可以跟很多条件，比如我们可以使用join语句从两张表中查询某些字段： 12CREATE VIEW test AS SELECT 列名1,列名2 FROM 表名1 INNER JOIN 表名2 ON 条件#条件比如可以是表1.列名1=表2.列名2 SQL 更新视图(好像没什么用)可以使用下面的语法来更新视图： 12SQL CREATE OR REPLACE VIEW SyntaxCREATE OR REPLACE VIEW 视图名 AS SELECT column_name(s) FROM table_name WHERE condition 现在，我们希望向 “Current Product List” 视图添加 “Category” 列。我们将通过下列 SQL 更新视图： 1234CREATE VIEW [Current Product List] ASSELECT ProductID,ProductName,CategoryFROM ProductsWHERE Discontinued=No SQL 撤销视图您可以通过 DROP VIEW 命令来删除视图。 12SQL DROP VIEW SyntaxDROP VIEW view_name SQL DATE(时间、日期)当我们处理日期时，最难的任务恐怕是确保所插入的日期的格式，与数据库中日期列的格式相匹配。 只要数据包含的只是日期部分，运行查询就不会出问题。但是，如果涉及时间，情况就有点复杂了。 在讨论日期查询的复杂性之前，我们先来看看最重要的内建日期处理函数。 Date函数下面的表格列出了 MySQL 中最重要的内建日期函数： 函数 描述 NOW() 返回当前的日期和时间 CURDATE() 返回当前的日期 CURTIME() 返回当前的时间 DATE() 提取日期或日期/时间表达式的日期部分 EXTRACT() 返回日期/时间按的单独部分 DATE_ADD() 给日期添加指定的时间间隔 DATE_SUB() 从日期减去指定的时间间隔 DATEDIFF() 返回两个日期之间的天数 DATE_FORMAT() 用不同的格式显示日期/时间 SQL Date数据类型MySQL 使用下列数据类型在数据库中存储日期或日期/时间值： DATE - 格式 YYYY-MM-DD DATETIME - 格式: YYYY-MM-DD HH:MM:SS TIMESTAMP - 格式: YYYY-MM-DD HH:MM:SS YEAR - 格式 YYYY 或 YY SQL 日期处理如果不涉及时间部分，那么我们可以轻松地比较两个日期！ 假设我们有下面这个 “Orders” 表： OrderId ProductName OrderDate 1 computer 2008-12-26 2 printer 2008-12-26 3 electrograph 2008-11-12 4 telephone 2008-10-19 现在，我们希望从上表中选取 OrderDate 为 “2008-12-26” 的记录。 我们使用如下 SELECT 语句： 1SELECT * FROM Orders WHERE OrderDate=&apos;2008-12-26&apos; 结果集： OrderId ProductName OrderDate 1 computer 2008-12-26 3 electrograph 2008-12-26 现在假设 “Orders” 类似这样（请注意 “OrderDate” 列中的时间部分）： OrderId ProductName OrderDate 1 computer 2008-12-26 16:23:55 2 printer 2008-12-26 10:45:26 3 electrograph 2008-11-12 14:12:08 4 telephone 2008-10-19 12:56:10 如果我们使用上面的 SELECT 语句： 1SELECT * FROM Orders WHERE OrderDate=&apos;2008-12-26&apos; 那么我们得不到结果。这是由于该查询不含有时间部分的日期。 提示：如果您希望使查询简单且更易维护，那么请不要在日期中使用时间部分！ SQL NULLNULL值是遗漏的未知数据。默认的表的列可以存放NULL值。 NULL如果表中的某个列是可选的，那么我们可以在不向该列添加值的情况下插入新纪录或更新现有的记录。这意味着该字段将以NULL值保存。 NULL值得处理方式与其他值不同。 NULL用作未知的或不是用的值得占位符。 注意：NULL值无法和0比较；他们是不等价的。 SQL 的 NULL值处理： 请看下面的 “Persons” 表： Id LastName FirstName Address City 1 Adams John London 2 Bush George Fifth Avenue New York 3 Carter Thomas Beijing 假如 “Persons” 表中的 “Address” 列是可选的。这意味着如果在 “Address” 列插入一条不带值的记录，”Address” 列会使用 NULL 值保存。 那么我们如何测试 NULL 值呢？ 无法使用比较运算符来测试 NULL 值，比如 =, &lt;, 或者 &lt;&gt;。 我们必须使用 IS NULL 和 IS NOT NULL 操作符。 IS NULL我们如何仅仅选取在 “Address” 列中带有 NULL 值的记录呢？ 我们必须使用 IS NULL 操作符： 12SELECT LastName,FirstName,Address FROM PersonsWHERE Address IS NULL 结果集： LastName FirstName Address Adams John Carter Thomas 提示：请始终使用 IS NULL 来查找 NULL 值。 IS NOT NULL我们如何选取在 “Address” 列中不带有 NULL 值的记录呢？ 我们必须使用 IS NOT NULL 操作符： 12SELECT LastName,FirstName,Address FROM PersonsWHERE Address IS NOT NULL 结果集： LastName FirstName Address Bush George Fifth Avenue SQL NULL函数SQL ISNULL()、NVL()、IFNULL()和COALESCE()函数请看下面的 “Products” 表： P_Id ProductName UnitPrice UnitsInStock UnitsOnOrder 1 computer 699 25 15 2 printer 365 36 3 telephone 280 159 57 假如 “UnitsOnOrder” 是可选的，而且可以包含 NULL 值。 我们使用如下 SELECT 语句： 12SELECT ProductName,UnitPrice*(UnitsInStock+UnitsOnOrder)FROM Products 在上面的例子中，如果有 “UnitsOnOrder” 值是 NULL，那么结果是 NULL。 微软的 ISNULL() 函数用于规定如何处理 NULL 值。 NVL(), IFNULL() 和 COALESCE() 函数也可以达到相同的结果。 在这里，我们希望 NULL 值为 0。 下面，如果 “UnitsOnOrder” 是 NULL，则不利于计算，因此如果值是 NULL 则 ISNULL() 返回 0。 SQL Server / MS Access 12SELECT ProductName,UnitPrice*(UnitsInStock+ISNULL(UnitsOnOrder,0))FROM Products Oracle Oracle 没有 ISNULL() 函数。不过，我们可以使用 NVL() 函数达到相同的结果： 12SELECT ProductName,UnitPrice*(UnitsInStock+NVL(UnitsOnOrder,0))FROM Products MySQL MySQL 也拥有类似 ISNULL() 的函数。不过它的工作方式与微软的 ISNULL() 函数有点不同。 在 MySQL 中，我们可以使用 IFNULL() 函数，就像这样： 12SELECT ProductName,UnitPrice*(UnitsInStock+IFNULL(UnitsOnOrder,0))FROM Products 或者我们可以使用 COALESCE() 函数，就像这样： 12SELECT ProductName,UnitPrice*(UnitsInStock+COALESCE(UnitsOnOrder,0))FROM Products MySQL 数据类型在 MySQL 中，有三种主要的类型：文本、数字和日期/时间类型。 Text 类型： 数据类型 描述 CHAR(size) 保存固定长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的长度。最多 255 个字符。 VARCHAR(size) 保存可变长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的最大长度。最多 255 个字符。注释：如果值的长度大于 255，则被转换为 TEXT 类型。 TINYTEXT 存放最大长度为 255 个字符的字符串。 TEXT 存放最大长度为 65,535 个字符的字符串。 BLOB 用于 BLOBs (Binary Large OBjects)。存放最多 65,535 字节的数据。 MEDIUMTEXT 存放最大长度为 16,777,215 个字符的字符串。 MEDIUMBLOB 用于 BLOBs (Binary Large OBjects)。存放最多 16,777,215 字节的数据。 LONGTEXT 存放最大长度为 4,294,967,295 个字符的字符串。 LONGBLOB 用于 BLOBs (Binary Large OBjects)。存放最多 4,294,967,295 字节的数据。 ENUM(x,y,z,etc.) 允许你输入可能值的列表。可以在 ENUM 列表中列出最大 65535 个值。如果列表中不存在插入的值，则插入空值。注释：这些值是按照你输入的顺序存储的。可以按照此格式输入可能的值：ENUM(‘X’,’Y’,’Z’) SET 与 ENUM 类似，SET 最多只能包含 64 个列表项，不过 SET 可存储一个以上的值。 Number 类型： 数据类型 描述 TINYINT(size) -128 到 127 常规。0 到 255 无符号*。在括号中规定最大位数。 SMALLINT(size) -32768 到 32767 常规。0 到 65535 无符号*。在括号中规定最大位数。 MEDIUMINT(size) -8388608 到 8388607 普通。0 to 16777215 无符号*。在括号中规定最大位数。 INT(size) -2147483648 到 2147483647 常规。0 到 4294967295 无符号*。在括号中规定最大位数。 BIGINT(size) -9223372036854775808 到 9223372036854775807 常规。0 到 18446744073709551615 无符号*。在括号中规定最大位数。 FLOAT(size,d) 带有浮动小数点的小数字。在括号中规定最大位数。在 d 参数中规定小数点右侧的最大位数。 DOUBLE(size,d) 带有浮动小数点的大数字。在括号中规定最大位数。在 d 参数中规定小数点右侧的最大位数。 DECIMAL(size,d) 作为字符串存储的 DOUBLE 类型，允许固定的小数点。 * 这些整数类型拥有额外的选项 UNSIGNED。通常，整数可以是负数或正数。如果添加 UNSIGNED 属性，那么范围将从 0 开始，而不是某个负数。 Date 类型： 数据类型 描述 DATE() 日期。格式：YYYY-MM-DD注释：支持的范围是从 ‘1000-01-01’ 到 ‘9999-12-31’ DATETIME() *日期和时间的组合。格式：YYYY-MM-DD HH:MM:SS注释：支持的范围是从 ‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’ TIMESTAMP() *时间戳。TIMESTAMP 值使用 Unix 纪元(‘1970-01-01 00:00:00’ UTC) 至今的描述来存储。格式：YYYY-MM-DD HH:MM:SS注释：支持的范围是从 ‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-09 03:14:07’ UTC TIME() 时间。格式：HH:MM:SS 注释：支持的范围是从 ‘-838:59:59’ 到 ‘838:59:59’ YEAR() 2 位或 4 位格式的年。注释：4 位格式所允许的值：1901 到 2155。2 位格式所允许的值：70 到 69，表示从 1970 到 2069。 * 即便 DATETIME 和 TIMESTAMP 返回相同的格式，它们的工作方式很不同。在 INSERT 或 UPDATE 查询中，TIMESTAMP 自动把自身设置为当前的日期和时间。TIMESTAMP 也接受不同的格式，比如 YYYYMMDDHHMMSS、YYMMDDHHMMSS、YYYYMMDD 或 YYMMDD。 暂时先学习到这儿…… 学习]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL使用记录]]></title>
    <url>%2F2018%2F11%2F12%2FMySQL%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[前言之前已经讲过MySQL的安装，这篇文章主要记录我在使用MySQL时遇到的各种问题和解决方法。 可视化工具的使用Navicat for MySQL是一套管理和开发MySQL的工具，实现了数据库可视化操作，对于新手来说安装一个可视化工具对于学习数据库有很大帮助。 Navicat for MySQL中文版，使用起来很方便。缺点就是这个软件收费，在网上看了一下正版1500；但是，早已经有人破解了这个软件。网上破解的方法有很多，我在这里就介绍一个最简单的方法： 下载链接：https://pan.baidu.com/s/1-6htt3CDzVlEIsurq8_fRw提取码：l6ho使用百度网盘下载上面文件，这里包含了Navicat安装包和破解程序，安装完成Navicat后运行PatchNavicat.exe选择navicat.exe 打开后破解就完成了。 使用安装完成后按照下图连接自己的MySQL 设置好了之后右键刚才新建的连接，然后点击打开连接。 我在做到这一步时出现了错误1251，大致是说不支持什么什么的，然后上网上查了一下，很快找到了解决方法： 在cmd登录到mysql然后执行： 123ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;password&apos; PASSWORD EXPIRE NEVER; #修改加密规则 ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;password&apos;; #更新一下用户的密码 FLUSH PRIVILEGES; #刷新权限 password可以修改成任意密码 还有一点要注意的是，在mysql命令行下，这些命令都要以;号结尾。 完成了之后再去Navicat打开连接就可以了 python连接mysql使用python连接mysql要首先下载mysql驱动： 1pip install mysql-connector 然后引入驱动操作mysql吧 12345678910# coding:utf-8__autor__ = 'ym'import mysql.connectorconn = mysql.connector.connect(user='root', password='password', database='test')cursor = conn.cursor()cursor.execute('CREATE TABLE student(id VARCHAR (20)PRIMARY KEY ,NAME VARCHAR (20))')cursor.execute("INSERT INTO test1 (id,name) VALUES ('1', '小绿')")cursor.execute("UPDATE student SET NAME='大蓝' WHERE (id='1')")conn.commit()cursor.close() 在上面的代码中，首先引入驱动 然后创建了连接 再创建了cursor 再执行SQL语句 然后和操作sqlite一样，提交事物，关闭游标。 （mysql语法需要多加练习，初次使用，报了很多错误。。。。准备下次专门写一篇记录mysql语法的文章。）]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fiddler抓包工具总结]]></title>
    <url>%2F2018%2F10%2F24%2FFiddler%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言我们使用计算机上的浏览器或者客户端软件要与外界进行通信，就必然会有数据的发送或接收，有的时候，我们需要对这些传递的数据进行分析，就需要截获这些传递的数据，其中对这些数据进行截获、重发、编辑、转存的过程叫做抓包。在写爬虫的时候，抓包分析用得相对来说也是较多的，要进行抓包，可以通过一些常见的抓包软件来实现，Fiddler就是一种常见的比较好用的抓包软件。 在写爬虫的时候借助Fiddler能够帮你你模拟出最真实的浏览器请求。 什么是FiddlerFiddler是一种常见的抓包分析软件，同时，我们可以利用Fiddler详细的对HTTP请求进行分析，并模拟对应的HTTP请求。目前抓包软件有很多，除了Fiddler之外，常见的还有： 浏览器自带的调试工具，按f12可以调出。缺点：比较轻量，不能支持一些复杂的抓包。 Wireshark，这是一款通用的抓包工具，功能比较齐全，正因为功能比较齐全，所以较为庞大，而我们写爬虫的时候主要是分析HTTP请求，所以这款软件的很多功能用不到。 爬虫和Fiddler的关系​ 网络爬虫是自动爬取网页的程序，在爬取的过程中必然涉及客户端与服务端之间的通信，自然也需要发送一些HTTP请求，并接受服务器返回的结果。在一些复杂的网络请求中，我们很难看到网址的变化规律，这就很难手动构造来请求来自动爬取网页了。 ​ 比如在浏览一些网页是，浏览到最下面的时候会出现一个‘’加载更多“的字样，此时点击就会加载出更多内容，然而我们观察浏览器中的网站并没有变化，便也无法分析出浏览器向服务器发送了什么数据。 ​ 此时可以使用Fiddler进行抓包，并对这些数据进行分析，这样就可以分析出实现”加载更多“的请求了。 安装和使用Fiddler下载地址从官网下载完成后安装，安装完成后打开 字段说明Fiddler想要抓到数据包，要确保Capture Traffic是开启，在File –&gt; Capture Traffic。开启后再左下角会有显示，当然也可以直接点击左下角的图标来关闭/开启抓包功能。Fiddler开始工作了，抓到的数据包就会显示在列表里面，下面总结了这些都是什么意思： Statistics 请求的性能数据分析随意点击一个请求，就可以看到Statistics关于HTTP请求的性能以及数据分析了 ## Inspectors 查看数据内容Inspectors是用于查看会话的内容，上半部分是请求的内容，下半部分是响应的内容： ## AutoResponder 允许拦截指定规则的请求AutoResponder允许你拦截指定规则的求情，并返回本地资源或Fiddler资源，从而代替服务器响应。 看下图5步，我将“baidu”这个关键字与我电脑“f:\Users\YukiO\Pictures\boy.jpeg”这张图片绑定了，点击Save保存后勾选Enable rules，再访问baidu，就会被劫持。AutoResponder有很多匹配规则： 字符串匹配（默认）：只要包含指定字符串（不区分大小写），全部认为是匹配 正则表达式匹配：以“regex:”开头，使用正则表达式来匹配，这个是区分大小写的Composer 自定义请求发送服务器Composer允许自定义请求发送到服务器，可以手动创建一个新的请求，也可以在会话表中，拖拽一个现有的请求Parsed模式下你只需要提供简单的URLS地址即可（如下图，也可以在RequestBody定制一些属性，如模拟浏览器User-Agent）Filters 请求过滤规则Fiters 是过滤请求用的，左边的窗口不断的更新，当你想看你系统的请求的时候，你刷新一下浏览器，一大片不知道哪来请求，看着碍眼，它还一直刷新你的屏幕。这个时候通过过滤规则来过滤掉那些不想看到的请求。勾选左上角的Use Filters开启过滤器，这里有两个最常用的过滤条件：Zone和Host Zone 指定只显示内网（Intranet）或互联网（Internet）的内容： Host 指定显示某个域名下的会话：如果框框为黄色（如图），表示修改未生效，点击红圈里的文字即可Timeline 请求响应时间在左侧会话窗口点击一个或多个（同时按下 Ctrl 键），Timeline 便会显示指定内容从服务端传输到客户端的时间：Fiddler 设置解密HTTPS的网络数据Fiddler可以通过伪造CA证书来欺骗浏览器和服务器。Fiddler是个很会装逼的好东西，大概原理就是在浏览器面前Fiddler伪装成一个HTTPS服务器，而在真正的HTTPS服务器面前Fiddler又装成浏览器，从而实现解密HTTPS数据包的目的。 解密HTTPS需要手动开启，依次点击： Tools –&gt; Fiddler Options –&gt; HTTPS 勾选Decrypt HTTPS Traffic 点击OKFiddler 抓取Iphone / Android数据包请参考我的另一篇博客 Fiddler 内置命令与断点Fiddler还有一个藏的很深的命令框，平时用的时候很容易忽略FIddler断点功能就是将请求截获下来，但是不发送，这个时候你可以干很多事情，比如说，把包改了，再发送给服务器君。还有balabala一大堆的事情可以做，就不举例子了。示例：?&lt;=@selectclsdump 断点命令断点可以直接点击Fiddler下图的图标位置，就可以设置全部请求的断点，断点的命令可以精确设置需要截获那些请求。如下示例：命令：bpafterbpsbpvg / go 本篇博客借鉴了：链接图片也来自：链接]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Fiddler</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Fiddler对手机APP抓包]]></title>
    <url>%2F2018%2F10%2F23%2F%E4%BD%BF%E7%94%A8Fiddler%E5%AF%B9%E6%89%8B%E6%9C%BAAPP%E6%8A%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[介绍Fiddler是一款抓包工具，具有很强大的功能，使用Fiddler不仅可以轻松抓取电脑端的数据包，还可以抓取手机、ipad的数据包。 使用在Fiddler官网下载并安装Fiddler，安装后打开界面如下： 因为fiddler抓包的原理就是通过代理，所以被测终端需要和安装fiddler的电脑在同一个局域网中。 开启Fiddler的远程连接，Fiddler 主菜单 Tools -&gt; Fiddler Options…-&gt; Connections页签，选中Allowremote computers to connect，并记住端口号为8888，等会设置手机代理时需要。设置好后重启fiddler保证设置生效。设置如下： 接下来要做的就是手机端的设置啦： 手机和电脑必须在同一个局域网内，然后打开wifi，进行以下设置： 代理服务器主机名就是电脑ip，端口就是Fiddler监听端口8888 然后在手机上点击任意app就可以看到有请求在Fiddler上面流动了 Fiddler的强大不止于此，Fiddler还能做很多事情，目前还在学习中。 原创文章，转载请注明出处！]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Fiddler</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo使用笔记]]></title>
    <url>%2F2018%2F10%2F17%2Fhexo%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[创建新文件在D:/个人博客/BLOG/source/_posts文件夹下执行命令hexo new ‘新文件名字’ 在文本中添加图片 把主页配置文件_config.yml里的post_asset_folder:这个选项设置为true(如过以后不想生成同名的文件夹了改为false即可) 在hexo目录下执行npm install hexo-asset-image –save,这是下载安装上传本地图片的插件。 等待安装完成后，再运行上面创建新文件的命令来生成新md文件时，/source/_posts文件夹中除了xxx.md文件还有一个同名的文件夹。 最后在xxx.md中想引入图片时，先把图片复制到这个文件夹中，然后只需要在xxx.md中按照markdown的格式引入图片：ps:!后面没有空格，hexo使用笔记前可加/也可以不加，图片名字一定不要写错。在页面中添加超链接关于文章推送的问题之前由于不会弄，导致每次推送时都把git上面的CNAME文件弄丢了，每次推送完之后还要重新创建CNAME文件，这样很麻烦。通过查阅资料知道了把CNAME文件放在本地hexo目录下source的_posts文件夹下就可以解决这个问题了。关于云解析首先要有一个域名，我用的是腾讯云域名：www和@主机记录的记录值是自己的githubpage的地址然后本地文件中要有一个CNAME文件，这个文件只有一行：这样就行了 原创文章，转载请注明出处！]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
