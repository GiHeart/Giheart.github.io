<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTTP理论基础]]></title>
    <url>%2F2018%2F10%2F24%2FHTTP%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[HTTP理论基础计算机网络体系结构OSI模型：osi参考模型讲计算机网络分为七层：（从低到高）物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。TCP/IP参考模型：TCP IP 被分为4层模型，分别是：网络接口层、网际层、传输层、应用层。 它把OSI模型的应用层表示层会话层合成应用层、数据链路层和物理层合为网络接口层。 网络接口层：由物理层和数据链路层合并而成。这层定义了与不同的网络进行连接的接口，网络接口层负责吧IP数据包发送到网络传输介质(双绞线、光纤等) 上传输，以及从网络传输介质上接收数据并解封，取出数据包并交给上一层网际层。 网际层：主要功能是负责将数据封装成包，并从源主机发送到目的主机，解决如何进行数据包的路由选择、阻塞控制、网络互连等问题。IP协议：网间互联协议 网际层的核心协议，另外还有一些辅助协议，包括ARP(地址解析协议)、RARP(逆向地址解析协议)、ICMP(网间控制报文协议)以及IGMP(互联网组管理协议)协议等。负责ip数据报在网络间寻址。IP协议可以进行IP数据包的分割与封装，封装前在数据包前加上源主机的ip地址和目的主机的ip地址及其他信息。特点：只提供传输，不负责纠错。ARP:负责将IP地址解析为物理地址，以便按该地址发送和接收数据。RARP:负责将物理地址解析为IP地址。ICMP:用于在主机和路由器之间传递控制消息，指出网络不通、为用户群进行软件升级、共享白板式多媒体应用等，这些情况就是多播。IGMP:负责对IP多播组进行管理，包括多播组成员的加入和删除等。 传输层：负责在源主机和目的主机的应用进程之间提供端到端的数据传输服务。负责数据分段、数据确认、丢失和重传等。 TCP:传输控制协议 是一个可靠的、面向连接的端对端的传输层协议，由TCP提供的连接叫虚连接。在发送方，TCP将用户提交的字节流分割成 若干个数据段并传递给网际层进行打包发送；在接收方，TCP将所接收的数据包重新装配并交付给用户，它通过序列确认及包重发机制解决IP协议传输时的错误 UDP:用户数据报协议 是一个不可靠的、面向无连接的出传输层协议。使用UDP协议发送报文之后无法得知其是否安全到达。UDP协议将可靠性问题交给应用程序来 解决。UDP协议应用于对那些可靠性要求不高，但要求网络延迟较小的场合，如语音和视频数据的传送。 -端口：为了识别传输层之上的各个不同的网络应用进程，传输层引入了端口的概念。要进行网络通信的进程向系统提出申请，系统返回一个唯一的端口号，将 进程和端口号联系在一起，成为绑定。传输层使用其报文头中的端口号，吧收到的数据送到不同的应用程序。端口是一种软件结构，包括一些 数据结构和I/O缓冲区。一些端口经常会被黑客、木马病毒所利用。 应用层：TCPIP的应用层综合了OSI应用层、表示层、以及会话层的功能。应用层为用户的应用程序提供了访问网络服务的能力并定义了不同主机上的应用程序之间交换用户 数据的一系列协议。由于不同的网络对网络服务的需求各不相同，因此应用层协议非常丰富，并且不断有新的协议加入， 应用层的常用协议： 超文本传输协议：HTTP 用于获取万维网上的网页信息 文件传输协议：FTP 用于点对点的文件传输 简单邮件传输协议：SMTP 用于发送邮件以及在邮件服务器之间转发邮件 邮局协议：POP用于重邮件服务器上获取邮件 仿真终端协议：TELNET 用于远程登录到网络主机 域名系统：DNS 域名解析 用于将主机域名解析为IP地址 简单网络管理协议：SNMP 用于从网络设备（路由器、网桥、集线器等）中收集网络管理信息。 TCPIP总结网络体系结构：计算机网络的层次及各层协议和层间接口的集合被称为网络结构IP提供的主要功能：1、寻址与路由2、数据包分割和重组，在数据包前加上源主机和目的主机的IP地址。网络接口层负责吧IP数据包发送到网络传输介质上传输，以及从网络传输介质上接收数据并解析，取出数据包交给网际层，网际层负责将数据封装成包，并从源主机发送到目的主机，解决的是数据包的路由选择、阻塞控制和网络互连等问题传输层负责在源主机和目的主机的应用程序之间提端到端的数据传输服务，负责数据分段、数据确认、丢失和重传等。应用层为用户的应用程序提供了访问网络服务的能力并定义了不同主机的应用程序之间交换用户数据的一系列协议。简单来说就是网络接口层吧数据送到网络传输介质上（网线）再把数据取出交给网际层，网际层封装数据并发送，传输层确保传输的数据是正确的应用层使用传输的各种数据在用户的应用程序上进行数据的交换等。 书上的总结：TCP协议先把数据分成若干数据报，并给每个数据加上一个TCP信封，上面写上数据报的编号，以便在接收端吧数据还原成原来的格式。IP协议把每个TCP信封再套上一个信封，在上面写上接收主机的地址。有了IP信封就可以在物理网络上传送数据。IP协议还具有利用路由算法进行路由选择的功能。这些信封可以通过不同的传输途径（路由）进行传输，由于路径不同以及其他原因，可能出现顺序颠倒、数据丢失、数据重复等问题。这些问题由TCP协议来处理，其具有检查和处理错误的功能，必要时还可以请求发送端重发。因此可以说IP协议负责数据的传输，TCP协议负责数据的可靠传输。 HTTP是应用层的协议，用于获取万维网上的网页信息。当我们浏览器输入百度网址后： 客户端请求：浏览器访问网址 www.baidu.com DNS：找到网址对应的IP地址 HTTP：请求的资源+请求的内容+请求IP地址等。 TCP:HTTP报文拆装成多个TCP报文，TCP报文按照三次握手可靠的传输。 IP：网络传输过程中 选择路径、进行中转。 服务端接收到了多个TCP报文。 服务端把接收到的TCP报文合并了http报文。读取到了信息。 服务端接受信息并返回资源给客户端，过程跟上面步骤一致。 http超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。 HTTP URL (URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息)的格式如下：http://host[&quot;:&quot;port][abs_path]http表示要通过HTTP协议来定位网络资源；host表示合法的Internet主机域名或者IP地址；port指定一个端口号，为空则使用缺省端口80；abs_path指定请求资源的URI；如果URL中没有给出abs_path，那么当它作为请求URI时，必须以“/”的形式给出，通常这个工作浏览器自动帮我们完成。eg:​ 输入：www.baidu.edu.cn​ 浏览器自动转换成：http://www.baidu.edu.cn/ HTTP协议–请求 http请求由三部分组成，分别是：请求行、消息报头、请求正文 请求方法（所有方法全为大写）有多种，各个方法的解释如下： GET 请求获取Request-URI所标识的资源 POST 在Request-URI所标识的资源后附加新的数据 HEAD 请求获取由Request-URI所标识的资源的响应消息 报头 PUT 请求服务器存储一个资源，并用Request-URI作为其标识 DELETE 请求服务器删除Request-URI所标识的资源 TRACE 请求服务器回送收到的请求信息，主要用于测试或诊断 CONNECT 保留将来使用 OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求​ HTTP协议–响应 在接收和解释请求消息后，服务器返回一个HTTP响应消息。 HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文 状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值： 1xx：指示信息–表示请求已接收，继续处理 2xx：成功–表示请求已被成功接收、理解、接受 3xx：重定向–要完成请求必须进行更进一步的操作 4xx：客户端错误–请求有语法错误或请求无法实现 5xx：服务器端错误–服务器未能实现合法的请求常见状态代码、状态描述、说明： 200 OK //客户端请求成功 400 Bad Request //客户端请求有语法错误，不能被服务器所理解 401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden //服务器收到请求，但是拒绝提供服务 404 Not Found //请求资源不存在，eg：输入了错误的URL 500 Internal Server Error //服务器发生不可预期的错误 503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常 ​ IP地址Internet网络中所有计算机均称为主机，ip地址由网络号和主机表示组成，目前使用的ipv4协议规定ip地址的长度为32位。一般以4个字节表示，每个字节用十进制表示，所以每个字节的取值是0-255，并且每个字节数之间用.割开，这种记录方法称为“点-分”十进制记号法。网络地址可分为五类 A类：分配给主要的服务提供商。IP地址的前八位二进制数代表网络类型 取值范围是0-127 B类：分配给拥有大型网络的机构。。。。。16。。。。。。。。。。。。。。。。128-191 C类：。。。。。。。。小型网络。。。。。24。。。。。。。。。。。。。。。。192-223 D类：为多路广播保留。取值224-239 E类：实验性地址，保留未用240-247 IP地址结构：网络类型+网络号+主机ID特殊IP：127.0.0.1 localhost本地主机 自己的电脑0.0.0.0 不是ip 请求这个地址代表所有请求被丢弃由于计算机的发展ipv4能表示的ip地址越来越紧张 且网络号即将用尽。所以产生了ipv6协议ipv6使用128位地址。支持的地址数是足够用的。 子网掩码子网掩码(subnet mask)：又叫网络掩码、地址掩码、子网络遮罩，它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。子网掩码是一个32位地址，用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在远程网上。子网掩码的设定必须遵循一定的规则。与二进制IP地址相同，子网掩码由1和0组成，且1和0分别连续。子网掩码的长度也是32位，左边是网络位，用二进制数字“1”表示，1的数目等于网络位的长度；右边是主机位，用二进制数字“0”表示，0的数目等于主机位的长度。这样做的目的是为了让掩码与ip地址做按位与运算时用0遮住原主机数，而不改变原网络段数字，而且很容易通过0的位数确定子网的主机数（2的主机位数次方-2，因为主机号全为1时表示该网络广播地址，全为0时表示该网络的网络号，这是两个特殊地址）。只有通过子网掩码，才能表明一台主机所在的子网与其他子网的关系，使网络正常工作。 网关网关(Gateway)：又称网间连接器、协议转换器。网关在网络层以上实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关既可以用于广域网互连，也可以用于局域网互连。 网关是一种充当转换重任的计算机系统或设备。使用在不同的通信协议、数据格式或语言，甚至体系结构完全不同的两种系统之间，网关是一个翻译器。与网桥只是简单地传达信息不同，网关对收到的信息要重新打包，以适应目的系统的需求。同层–应用层。 DHCPDHCP协议：路由器自动为局域网下的客户端分配局域网ip。好处是比较方便不用手动设置ip。 DNS域名解析协议 将域名转化为ip地址]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日志2018.10.23]]></title>
    <url>%2F2018%2F10%2F23%2F%E6%97%A5%E5%BF%972018-10-23%2F</url>
    <content type="text"><![CDATA[问题： 上午在使用requests.Session()获取登录后的知乎首页时遇到了问题，知乎首页不知道用了什么编码，获取到数据后使用UTF-8/GBK都无法正常解码，都是一堆乱码。现在这个问题还没有解决，手足无措了。 下午学习scrapy框架时也遇到了很多问题，安装和运行都很麻烦，我打算在学习完这个框架之后再来总结。 收获： 在爬取知乎首页时，学习到了decode()的第二个参数，ignore 在获取到网页的数据后，有一些特殊字符导致不能使用decode解码 在这里我直接加上了ignore参数忽略了不能解码的特殊字符 scrapy: scrapy的安装是真的麻烦： 首先要安装Visual C++ Build Tools，因为接下来要安装的两个文件的底层是基于C语言开发的，所以需要C语言的编译环境 下载地址有可能会提示下载.NET Framework下载地址 安装pywin32,下载地址下载.whl文件后使用pip install 文件名(包含后缀) 安装Twisted,下载地址安装方法同上 然后就是pip install scrapy了 使用： 创建工程命令scrapy startproject 名称 cd 名称 scrapy genspider 爬虫名 要爬的网址 eg:scrapy genspider explam baidu.com 修改settings文件，修改ROBOTSTXT_OBEY=False python执行SCRAPY SHELL 提示DEF WRITE(SELF, DATA, ASYNC=FALSE)出错的问题解决： 只需要把python里面manhole.py文本的所有的async替换成其他名字就行，修改python\Lib\site-packages\twisted\conch\manhole.py文件 把这里的所有async改个名字就行了]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>日志</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Fiddler对手机APP抓包]]></title>
    <url>%2F2018%2F10%2F23%2F%E4%BD%BF%E7%94%A8Fiddler%E5%AF%B9%E6%89%8B%E6%9C%BAAPP%E6%8A%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[介绍Fiddler是一款抓包工具，具有很强大的功能，使用Fiddler不仅可以轻松抓取电脑端的数据包，还可以抓取手机、ipad的数据包。 使用在Fiddler官网下载并安装Fiddler，安装后打开界面如下： 因为fiddler抓包的原理就是通过代理，所以被测终端需要和安装fiddler的电脑在同一个局域网中。 开启Fiddler的远程连接，Fiddler 主菜单 Tools -&gt; Fiddler Options…-&gt; Connections页签，选中Allowremote computers to connect，并记住端口号为8888，等会设置手机代理时需要。设置好后重启fiddler保证设置生效。设置如下： 接下来要做的就是手机端的设置啦： 手机和电脑必须在同一个局域网内，然后打开wifi，进行以下设置： 代理服务器主机名就是电脑ip，端口就是Fiddler监听端口8888 然后在手机上点击任意app就可以看到有请求在Fiddler上面流动了 Fiddler的强大不止于此，Fiddler还能做很多事情，目前还在学习中。 原创文章，转载请注明出处！]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Fiddler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习记录2018.10.22]]></title>
    <url>%2F2018%2F10%2F22%2F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952018-10-22%2F</url>
    <content type="text"><![CDATA[随便写写现在已经晚上了，目前为止今天还没有学习新知识。不知道为什么，每次放完假回来就得一天时间来调整学习状态，说到底还是懒。。。 上个周末，英雄联盟s8全球总决赛已经来到了1/4决赛。对于我这个loler来说自然很关注，甚至周六上自习的时候都在偷偷看比赛直播。我玩英雄联盟差不多四年了，s4开始，现在已经s8了。我对这个游戏真是又爱又恨，恨的是自己在这个游戏上面投入了太多时间，说网瘾少年真的一点都不为过，但这个游戏也带给了我很多快乐，对于我们这样一群人来说，娱乐就是几朋友一块开黑玩几把，互相嘴臭。这届世界赛频频爆冷，世界第一赛区，从s3开始统治英雄联盟的最强赛区LCK竟然全部倒在了8强，而我们LPL也仅剩1支开始不被多数人看好的IG挺进了4强。分析这届总决赛，不难发现，传统的打法已经不适应版本了，而LCK，LPL的大多数队伍都还在固步自封，不肯接受新的东西，这才导致了这么多冷门的爆出。最令我失望的就是RNG了，这个从春天开始包揽所有冠军的队伍，竟然倒在了8强。当然我也不是喷子，我也不想喷RNG的表现有多糟糕，也没有心思去贴吧微博骂人。虽然这只是个在外人看来玩物丧志的游戏比赛，但是我从中也明白了很多。骄兵必败，这句话用来形容RNG在合适不过了，这支RNG今年拿了太多冠军，广告代言接到手软。就在S赛期间，UZI又拿到了NIKE的代言 这个英雄联盟的ADC选手越来越商业化了。RNG在今年也拿到了很多大牌赞助，奔驰，惠普，谷粒多，这或许也为今年的总决赛惨败埋下了伏笔。全员膨胀，自认为对手G2与自己实力天差地别，人家实力确实跟你有差距，但没有这么离谱吧，把把把对面不当人，从教练到选手。结果就是送给观众一场屎一样的BO5，也已RNG的惨败结束。RNG不是没有实力赢下G2，赛前大部分人（包括解说）都预测3:0带走对面的，结果队员无限膨胀，不认真对待比赛，以惨败收场。总结下来就是RNG输给了骄傲，输给了自己的态度。现在想想8强抽签时候的那副嘴脸真是充满了讽刺。 我突然想到了易大师说的话： 不要被骄傲遮蔽了双眼 真正的大师永远都怀着一颗学徒的心 其实关于这个比赛还有很多事情能给我们带来很多启示。 等等，我这个题目不是学习记录吗，怎么扯到游戏上了，我佛了。关于游戏，要是让我放开了讲，我能给你说一天一夜，我就不多BB了，毕竟学习现在才是我该干的事情。 记录下学习中遇到的问题吧今天我好像真的没有看一点新知识。那就记录下上周六写爬虫吧，上周六闲来无事，写了个小爬虫。在写这个爬虫的时候也是遇到了很多问题值得我记录下。首先，关于一个请求返回的数据，有些异步请求返回的是json数据，就像腾讯视频的视频评论就是json数据，这里就需要用到json解析数据才能作为Python的字典使用了，开始我一直想用正则表达式把这个jaon提取出来，因为在json数据之前还包含了一串没用的字符串导致这个数据不能直接使用json.loads()解析，正则表达式试了半天，就是无法剔除那个无关信息，还包括括号，正则表达式对于现在的我来说确实有点困难。不得已向前辈请教，他一语道破天机“为什么不试试字符串切片呢？”对啊，这个问题用个简单的切片就完事了，我还在苦苦寻求正则表达式，这也启示了我解决问题的方式。明明有简单的方法，怎么没想到呢；下次再遇到类似的问题先想想除了第一个想到的解决方法之外还有没有其他的方法。 还有就是我在把数据写进数据库的时候，提示错误，key不能包含 . 我又无奈了，还是去请教，大佬说replace可以吧 . 替换成其他字符，我一想replace不是字符串的方法吗，于是马上提出疑问，结果大佬一句话让我哑口无言，key不就是字符串吗？ 是啊，我咋又没想到呢？= =真的是醉了。希望自己吃一堑，长一智，能够记住这些问题吧。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[a_jax获取数据的另一种方式]]></title>
    <url>%2F2018%2F10%2F19%2Fa-jax%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言有一些网站在发起AJAX请求的时候，会带上特殊的字符串用于身份验证。这种字符串称为Token。比如说会带上时间戳，时间戳精确到毫秒。还会跟另一个属性存在某种一一对应的关系，虽然这种对应关系的算法会写在网站的某一个JavaScript文件中，但是要想读懂这种关系需要深厚的JavaScript功底。如果一个网站只需要爬一次，或者对爬取速度没有什么要求，那么可以通过另一种方式来解决这种问题。本文就来介绍这种方法是如何实现的! SeleniumSelenium介绍虽然网页的源代码中无法看到被异步加载的内容，但是Chrome浏览器开发者工具的’Elements’选项卡下却可以看到网页上的内容。这就说明Chrom开发者工具Elements选项卡里的HTML代码和网页源代码中的HTML代码是不一样的。在开发者工具中，此时显示的内容是已经加载完成的内容。如果能够获得这个被加载的内容，那么就能绕过手动构造Token的过程，可以直接使用XPath或者正则来获得想要的内容。这种情况下，就需要使用Selenium操作浏览器来解析JavaScript，在爬取被解析以后的代码。Selenium是一个网页自动化测试工具，可以通过代码来操作网页上的各个元素。Selenium是Python中的第三方库，可以实现用Python来操作网页。 安装pip install selenium下载ChromDriver，根据自己的系统选择合适的版本：下载下来的是一个zip文件，解压完成后得到一个exe文件接下来就是使用了 使用将上面解压得到的chromedriver.exe与代码放在同一个文件夹中以方便代码直接调用。初始化Selenium，导入selenium库，在指定WebDriver如果chromedriver与代码不在同一个文件夹中可以通过绝对路径来指定，需要注意的是在Windows中路径的分隔符’\’和Python中的转义字符’\’冲突，所以在指明绝对路径的时候可以在路径字符串左引号的左边加一个‘r’符号：1driver = webdriver.Chrome(r&apos;D:\user\asd\chromedriver&apos;) 这样Python就能正确处理反斜杠的问题。初始化完成以后下面第7行的代码就是使用selenium打开网页啦。代码运行以后会自动打开一个chrome浏览器窗口，并自动打开这个网址对应的页面。一旦被异步加载的内容出现在了这个窗口中，那么这是使用：1html = driver.page_source 就能得到在开发者工具中出现的HTML代码。如下图所示：上图中标明的第6行代码设置了一个5s的延迟，这是由于selenium并不会等待网页加载完成在执行后面的代码。它是向ChromeDriver发送了一个命令，让ChromeDriver打开某个网页。至于网页需要多久打开，多久才能完成异步加载，这些selenium并不管，所以才需要设置一个延迟等待异步加载完成之后再抓取网页信息。这样手动设置延迟的方式很浪费时间资源，并且如果在指定的延迟时间内网页还没有加载出来，那么就获取不到网页信息了。怎么让selenium智能化呢？请看以下代码1234567891011121314from selenium import webdriverfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support import expected_conditions as ECdriver = webdriver.Chrome(&apos;./chromedriver&apos;)driver.get(&apos;http://exercise.kingname.info/exercise_advanced_ajax.html&apos;)try: WebDriverWait(driver, 30).until(EC.text_to_be_present_in_element((By.CLASS_NAME, &quot;content&quot;), &apos;通关&apos;))except: print(&apos;网页加载太慢&apos;)element = driver.find_element_by_xpath(&apos;//div[@class=&quot;content&quot;]&apos;)print(element.text) WebDriverWait(driver, 30).until(EC.text_to_be_present_in_element((By.CLASS_NAME, “content”), ‘通关’))WebDriverWait会阻塞程序的运行，30表示最多等待30s。在这30秒内，每0.5秒检查一次网页，直到expected_conditions（EC）期待条件，这个条件就是text_to_be_present_in_element((By.CLASS_NAME, “content”)，（注释：class为content的元素里面的文本中包含了通关两个子）出现。所以这行代码的完整意思就是等待网页加载，直到class为countent的元素里面包含了”通关”两个汉字。By除了指定class之外，还可以指定很多其他的属性，例如： By.ID By.NAME 当然，也可以使用XPth:1EC.present_of_element_located((By.XPATH,&apos;//div[@class=&quot;content&quot;])) 需要注意的是：”present_of_element_located”的参数是一个元组，元组第0项为By.XX，第1项为具体内容，”text_to_be_present_in_element”的参数有两个第一个参数为一个元组，元组第0项为By.XX，第1项为具体内容；第二个参数为部分或全部文本，又或者是一段正则表达式。 获取元素在网页中寻找需要的内容，可以使用XPath12element = driver.find_element_by_xpath(&apos;//div[@class=&quot;content&quot;]&apos;)print(element.text) driver.find_element_by_xpath如果有多个符合条件的返回第一个driver.find_elements_by_xpath以列表形式返回所有的符合条件的element推荐使用driver.find_elements_by_xpath因为driver.find_element_by_xpath返回的是一个Element对象，如果没有符合条件的元素，就会报错，而driver.find_elements_by_xpath返回的是一个Element对象列表，就算没有符合条件的元素也会返回一个空列表，不会报错。因为driver.find_element_by_xpath返回的是一个Element对象,通过它的.text属性才能获取到文本信息，当使用driver.find_elements_by_xpath得到了一个Element对象列表时，可以通过for循环展开这个列表然后在通过.text属性来获取到文本信息。一定要注意，不能直接在XPath的末尾加上text()，会报错。 原创文章，转载注明出处]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>爬虫</tag>
        <tag>a_jax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2018%2F10%2F19%2Ftest%2F</url>
    <content type="text"><![CDATA[test]]></content>
      <categories>
        <category>私密博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo文章加密]]></title>
    <url>%2F2018%2F10%2F19%2Fhexo%E6%96%87%E7%AB%A0%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[hexo文章简单加密访问方法来源于简书这里只介绍怎么实现，具体原理访问上面链接 实现找到themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件。按道理是添加在任何地方都行，但是推荐加在所有的标签之后，个人建议，仅做参考。以下是原作者加的代码：12345678910&lt;script&gt; (function()&#123; if(&apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; if (prompt(&apos;请输入文章密码&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; alert(&apos;密码错误！&apos;); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 再写新博客的时候在顶部加上新属性如下图所示：description是描述password后就是自定义的密码了具体效果如下图所示： 原创文章，转载请注明出处！]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础复习]]></title>
    <url>%2F2018%2F10%2F19%2Fpython%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[基础复习基础类型控制语句基础类型： 整数型 int 浮点数 float 字符串 str 布尔值 True、Flase 空值 None 变量 变量在计算机中不仅可以是数字，还可以是任意数据类型，变量在称剧中就是用一个变量名表示 字符串详解===转义字符:因为一些特殊字符是python中的关键字或一些特殊的概念如换行。所以以特殊字符 \ 开头，构造转义字符。常见的转义字符：\n 换行 \t 制表符\’ 单引号 \” 双引号\ 反斜杠 遍历：for i in ‘abc’: print(i)‘a’,’b’,’c’ 下标访问：‘hello’[4]→o 搜索：(了解)’字符串’.count(子字符串) 搜索子串出现次数‘xyaxyaXY’.count(‘xy’)→ 2‘xyaxyaXY’.count(‘xy’, 2)(了解)判断字符串是否以某个字母开头→ 1‘abcd’.startswith(‘a’)→ True‘abcd’.endswith(‘d’)→ True 字符串.find(子串) 找到返回下标，未找到返回-1‘axyaXY’.find(‘xy’)→ 1‘aaXY’.find(‘xy’)→ -1index()方法与find()类似，区别是未找到的时候报错。 替换 ：字符串.replace(老子串，新字符串)‘aaXY’.replace(‘aa’, ‘bb’)‘bbXY’分隔：(了解)partition把一个字符串切成几块并返回，包含子串。‘xyaxyaXY’.partition(‘xy’)(‘’, ‘xy’, ‘axyaXY’) 字符串.split(子串)，根据子串分成几部分并返回列表，不包含子串。‘xyaxyaXY’.split(‘x’)[‘’, ‘ya’, ‘yaXY’] 连接：join()用一个字符串连接可迭代对象的各个项。‘-‘.join([‘小明’, ‘hong’, ‘li’])→ ‘小明-hong-li’ 删除：字符串.strip(要删除的子串)‘今天天气真好\n’.strip(‘\n’)→ ‘今天天气真好’ 大小写转换：‘aa AA’.lower()→ ‘aa aa’‘aa AA’.upper()→ ‘AA AA’‘hello world’.capitalize()→ ‘Hello world‘aa AA’.swapcase()→ ‘AA aa’ isxxx判断:判断是否字母‘a’.isalpha()→ True判断是否空格‘ ‘.isspace()→ True判断是否数字‘1’.isdigit()→ True判断是否合法的变量名‘a4’.isidentifier()→ True 填充：对齐的时候会用到‘’.center(填充后的字符串总长度，要填充的字符串)‘abc’.center(5, ‘_’)→ ‘abc‘右侧填充‘abc’.ljust(10, ‘_’)→ ‘abc_______’左侧填充‘abc’.rjust(10, ‘_’)→ ‘___abc’ （以上了解end） 判断变量类型 type()函数 判断变量类型 isinstance(值， 类型) 如果值属于类型的话返回True 数据类型转换 int(x) 将x转换为一个整数 long(x) 将x转换为一个长整数 float(x ) 将x转换到一个浮点数 complex(real) 创建一个复数 str(x ) 将对象 x 转换为字符串 repr(x ) 将对象 x 转换为表达式字符串 eval(str ) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s ) 将序列 s 转换为一个元组 list(s ) 将序列 s 转换为一个列表 chr(x ) 将一个整数转换为一个字符 unichr(x ) 将一个整数转换为Unicode字符 ord(x ) 将一个字符转换为它的整数值 hex(x ) 将一个整数转换为一个十六进制字符串 oct(x ) 将一个整数转换为一个八进制字符串 控制语句：if else语句12345678if 条件a: 执行1elif 条件b: 执行2elif 条件c: 执行3else： 执行4 循环for循环：123打印三次字符串for i in range(1,4): print(&apos;你好 我是你爸&apos;) while 循环1234567891011121314151617181920i = 1while i&lt;4: print(&apos;你好 我是你爸&apos;) i+=1#循环中也可以加入条件控制语句i = 0while i &lt;10: i = i+1 if i %2 == 0: continue#当i是偶数时跳过此次循环 print(i)#break语句：用来结束循环i = 0while i &lt;10: i = i+1 print(i) if i == 6: break 字典列表元组列表list：定义：原来的单值变量无法满足业务需求，需求一个”容器“来装内容列表存储一些列有序（有下标）数据。容器内可以保存整数、布尔、字符串、或其他容器语法：创建一个列表：list1 = [1,’a’]还可以通过类 内置关键字创建 list1 = list() 添加项： append()方法，添加新项到列表的末尾list.append(要添加的数据) insert()方法，可以根据索引值插入制定数据。list.insert(索引，要添加的数据) for 循环 +append,批量添加项。list1 = [1,2,3,4]for i in range(5, 8): list1.append(i)print(list1) 两个列表拼接，用加号list1 = [1,2,3]list2 = [4,5,6]list3 = list1 + list2 删除项： pop()list.pop(索引)，根据索引删除列表中的某一个元素，返回删除成功的元素。pop()不传索引参数的时候，默认删除列表最后一项。pop()函数相当于append和insert函数的逆运算。 remove()list.remove(想要删除的项目值) 根据项item的值value来删除 clear()清空列表lisr.clear() 清空所有项目，返回空列表。 del删除列表对象，根据索引删除元素list = [1,2,3,4]del list[0]表示删除的是1 访问查询：通过索引（下标）list[0] 修改：修改基于索引的。访问列表下标，然后等号赋值。list [索引] = 新值 遍历：列表是一个可迭代对象，通过for循环可以吧一个列表中的元素依次取出如果判断一个对象是可迭代对象：通过collections模块的Itearable类型来判断。from collections import Iterableisinstance(‘abc’,Iterable)#判断字符串abc是否可以迭代True#返回true代表可以迭代list = [1,2,3,4]for i in list: print(i)#循环遍历出列表所有元素。 切片：列表[索引开始：索引结束：步进]切割截取出来区间。切片参数为负数是，截取方向向右为正，步进为正式才能截取。步进与截取方向相反时，结果为空索引0可以省略list[0:2] 等同于 list[:2]反向reverse输出列表list[::-1] &gt;&gt;&gt; [5, 4, 3, 2, 1] 列表生成式（不常用）12345678list1 = []for i in range(1,5) list1.append(i)#同样是在列表中加入1,2,3,4也可以用列表生成式写：[i for i in range(1,5)]#列表生成式也可以加入条件判断[i for i in range(1,10) if i%2==0]输出偶数 字典字典也是一种容器，特点：键值对存储没有索引，是无序的。靠键来增删改查 创建： 内置类实例化创建dict1 = dict() 大括号，内容空dict1 = {} 创建时附初始值dict1 = {‘name’: ‘小明’, ‘age’: 13, ‘sex’: ‘male’} 查询： （常用）dict1[键key]dict1 = {‘name’: ‘小明’, ‘age’: 13, ‘sex’: ‘male’}dict1[‘name’] &gt;&gt; ‘小明’如果键不存在的话，报 KeyError错误。dict1[‘aaa’] &gt;&gt;&gt; KeyError:aaa get(键, 默认值)跟dict[键]非常相似，只不过多了个默认值。当键不存在的时候会报Nonedict1.get(‘name’) &gt;&gt;&gt; ‘小明’dict1.get(‘aaa’, None) &gt;&gt;&gt; None 添加：dict[新建] = 新值 修改：dict[键] = 新值 遍历：先dict.items() 转换为 大列表套小列表项的形式。再用 for 循环遍历出来。for k,v in 字典.items(): print(k, v)dict.keys()吧字典中的key取出来dict.values()把字典中的value取出来 删除： 键访问，值设置为None, 键还在字典[键] = Nonedict1 = {‘name’: ‘小明’, ‘age’: 13, ‘sex’: ‘male’}dict1[‘name’] = Nonedict1[‘name’] &gt;&gt;&gt; None （常用）字典.pop(键) 根据键删除，返回删除成功的值，会把键和值都删除dict1 = {‘name’: ‘小明’, ‘age’: 13, ‘sex’: ‘male’}dict1.pop(‘name’) &gt;&gt;&gt; ‘小明’dict1 &gt;&gt;&gt; {‘age’: 13, ‘sex’: ‘male’} del 字典[键]， del关键字删除，没有返回值，会把键和值都删除 字典.clear() 删除所有内容dict1.clear()dict1 &lt;&lt;&lt; {} 其他的常用方法：dict.items() 返回一个列表，每一项是 键值对dict.keys() 返回一个列表，每一项是字典里的 键dict.values() 返回一个列表，每一项是字典里的 值dict.contains(key) 键存在的话返回True，不存在返回False 元组元组跟list非常相似，特点和区别是 “不可修改”。所以元组需要在创建的时候就指定数据。语法是小括号括起来，逗号分隔每一项 创建:tuple2 = tuple((10, 20, ‘张三’))（常用）tuple1 = (10, 20, ‘张三’)场景:元组由于不可变，适合定义 常量、配置、不需要改变的值。这样在复杂代码中就不用害怕因为bug误修改值。例如定义 中国的所有省份，一个注册登录表单中的下拉框选项 查询:有索引，通过下标访问tuple[index]tuple2 = (‘河南’, ‘云南’)tuple2[0] &gt;&gt;&gt; ‘河南’ 也支持切片:tuple2[0:1] &gt;&gt;&gt; (‘河南’,) 注意的一个地方元组有时只有一项的时候，后面仍有一个逗号。原创文章，转载请注明出处！]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分享一种在markdown中插入图片的新方法]]></title>
    <url>%2F2018%2F10%2F18%2F%E5%88%86%E4%BA%AB%E4%B8%80%E7%A7%8D%E5%9C%A8markdown%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E6%96%B0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言我在前面的hexo使用笔记中介绍过怎么插入图片，前面那种方法虽然能用，但还是有点麻烦，每次插入图片都要写一段markdown代码。每次创建新博客的时候都会新建一个md文件和一个文件夹，不仅麻烦而且还让博客文件夹变得不简洁。下面我介绍一种新的方法，既不用创建新的存放图片的文件夹，而且还自动生成markdown语法代码，再插入图片的时候直接ctrl+v就完事了，看起来是不是很方便呢？ 介绍下面进入正文，这种酷炫的新方法来自于大佬的git链接MarkdownPicPicker 是一个Markdown写作辅助工具。它能将剪贴板中的图片上传到网络图床中，并将markdown格式的图片链接(![]（&lt;图片地址&gt;))复制到剪贴板中。项目的readme中指明了安装使用方法下载链接下载完成后并解压，解压完成后得到一个MarkdownPicPicker.exe可执行文件和一个pic文件夹。 使用截图之后，比如我使用qq的快捷键截图，然后运行一下MarkdownPicPicker.exe，在你的编辑器中按下ctrl+v,神奇的事情就发生了，你会直接得到一段markdown插入图片的代码。是不是比上次的方法方便多了。如果你只想复制链接，不想让他变成这种形式，那么，你可以在命令行中输入markdownpicpicker.exe -linkonly 优化如果你觉得上面的方法还不够方便？是不是每次还要用鼠标来运行exe文件觉得很麻烦？没关系，还有一种方法可以优化这些步骤。官方文档说使用AutoHotKey来启动程序可以吧整个流程缩短到两秒钟 AutoHotkeyAutoHotKey是什么东西？我其实也是第一次听说这个什么软件，完全一脸懵比，上网上查了下才知道是干什么用的，在官网上下载之后然后运行出来发现是一份英文帮助文档，我也看不懂说的是什么。后面才知道这是个脚本程序，可以自定义快捷键来执行某个程序或某种命令。 ## 怎么使用呢？新建一个文本本件，名字随便起，然后把后缀名改为.ahk然后编辑这个文件输入以下代码： 1234#b::Run, D:\git第三方包和软件\MarkdownPicPicker_v1.0.0\markdownpicpicker.exeReturn!b::Run, D:\git第三方包和软件\MarkdownPicPicker_v1.0.0\markdownpicpicker.exe -linkonlyReturn 在鼠标右键点击run script即可运行。这里定义了两个快捷键，第一行代码表示按下键盘win+b键执行markdownpicpicker.exe第三行表示按下alt+b执行markdownpicpicker.exe -linkonly这和在命令行中的执行文件是一样的。关于autohotkey还有很多作用，请自行baidu,google。 原创文章，转载请注明出处！]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python与MongoDB]]></title>
    <url>%2F2018%2F10%2F18%2Fpython%E4%B8%8EMongoDB-1%2F</url>
    <content type="text"><![CDATA[MongoDB介绍：MongoDB是一款基于c++开发的开源文档数据库，数据在MongoDB中以Key-Value的形式存储，就像是python的字典一样。使用MongoDB的管理软件Robo3T可以实现数据库的可视化。 安装：首先下载并解压MongoDB:访问官网，从官网上下载：官网下载选择适合自己的版本和操作系统然后Download就可以了解压后把Bin下的文件辅助到新的文件夹（在c盘或者d盘创建MongoDB文件夹）并创建存储数据库的文件夹Data和日志文件夹Log并创建mongod.conf，操作完成后文件目录如下图所示：接下来就是编辑mongod.conf了使用notepad++或其他除了编辑器(除了记事本)打开mongod.conf然后将以下代码复制进去：12345678910systemLog: destination: file path: D:\MongoDB\Log\mongo.log logAppend: truestorage: dbPath: D:\MongoDB\Datanet: bindIp: 127.0.0.1security: authorization: disabled 这里的path和dppath根据设置成自己的路径，比如我的Log和Data是放在D盘MongoDB文件夹下的。然后在安装目录下启动命令行，输入：1mongod.exe --config mongod.conf 即可启动Mongodb(ps:启动后不能关闭这个窗口哦，否则mongodb服务会被关闭，还有一种方法可以将mongodb设置为windows服务启动，这样就不用每次输入命令启动啦，不过这种方法我还没有研究怎么用，等我会使用了在更新。) Robo 3T介绍Robo 3T是一个快平台的MongoDB管理工具，可以在图形界面中查询或者修改MongoDB 下载和安装访问官网下载robo3t选择Download robo3t等待安装完成后打开 使用单机create链接(如下图),如果monggodb在本地计算机上面运行，只需要在Name这一栏填一个名字就可(也可以不填使用默认名字)，单击save即可然后点击connect就可以连接MongoDB了可以看到，数据在MongoDB中是按照库(Database)——集合——文档的层级关系来存储的。文档就像是python中的一个字典，集合相当于一个包含了很多字典的列表；库相当于一个大字典，大字典里面的每一个键值对都对应了一个集合，key为集合的名字，Value就是一个集合。 PyMongo安装1pip install pymongo pymongo的使用使用pymongo初始化数据库连接12345from pymongo import MongoClientclient = MongoClient()database = client[&apos;库名&apos;]#创建一个库collection = database[&apos;集合名&apos;]#创建一个集合#这里的库名和集合名除了可以是字符串还可以是一个变量，当库名或者集合名是一个变量的时候，可以通过循环来批量操作数据库，比如要创建多个集合的时候，可以吧集合名先保存到一个列表中，然后通过循环穿件多个集合。 插入数据插入操作用到的方法为insert(参数)参数就是python的字典。 123456789101112131415from pymongo import MongoClientclient = MongoClient()database = client[&apos;Chapter6&apos;]collection = database[&apos;spider&apos;]data = &#123;&apos;id&apos;: 2, &apos;name&apos;: &apos;张三&apos;, &apos;age&apos;: 20, &apos;salary&apos;: 9999&#125;collection.insert(data)#插入一条数据#当然也可以一次插入多条数据，先把多条数据保存到一个列表中，然后直接使用insert()即可more_data = [ &#123;&apos;id&apos;: 3, &apos;name&apos;: &apos;张四&apos;, &apos;age&apos;: 20, &apos;salary&apos;: 999&#125;, &#123;&apos;id&apos;: 4, &apos;name&apos;: &apos;张五&apos;, &apos;age&apos;: 20, &apos;salary&apos;: 99&#125;, &#123;&apos;id&apos;: 5, &apos;name&apos;: &apos;张六&apos;, &apos;age&apos;: 20, &apos;salary&apos;: 9&#125;, &#123;&apos;id&apos;: 6, &apos;name&apos;: &apos;张七&apos;, &apos;age&apos;: 20, &apos;salary&apos;: 19999&#125;]collection.insert(more_data) 查找数据查找功能对应的方法是 12find(查询条件，返回字段)#返回所有符合的信息find_one(查询条件，返回字段)#返回一条符合的信息 在不写find方法参数的时候，表示获取指定集合中所有字段。返回字段的参数指定返回内容。这个参数也是一个字典，key就是字段的名称，value是0或1,0表示不返回这个字段，1表示返回这个字段。其中_id这个字段比较特殊，必须人工指定它的值为0，这样才不会返回。而对于其他数据，应该统一使用返回，或者不返回。eg: 1collection.find(&#123;&apos;age&apos;:20&#125;,&#123;&apos;_id&apos;:0&#125;)#查询所有age为20的记录，返回除了_id的所有字段 这里需要知道：find()方法返回的是一个pymongo对象，这个对象可以被for循环展开，展开之后可以得到很多个字典。pymongo也支持逻辑查询：它们对应的关键词如下所示： $gt great than 大于 $lt less than 小于 $gte Greater than equal to 大于等于 $lte less than equal to 小于等于 $eq equal to 等于 $ne not equal to 不等于eg: 12collection.find(&apos;age&apos;:&#123;&apos;$gt&apos;:19&#125;)#查询age&gt;19的记录collection.find(&apos;age&apos;:&#123;&apos;$gte&apos;:19,&apos;$lt&apos;:30&#125;)#查询19≤age&lt;30的记录 对查询结果进行排序排序的方法为sort(),这个方法一般和find()配合使用他有两个参数，第一个参数指明以那一项进行排序，第二个参数为1或者-1，1表示升序，-1表示降序。eg: 1collection.find(&apos;age&apos;:&#123;&apos;$gt&apos;:19&#125;).sort(&apos;age&apos;,-1)#查询所有age大于19并以age按照降序进行排序。 修改修改也有两个方法： 12collection.updata_one(参数1，参数2)#修改一条collection.updata_many(参数1，参数2)#修改多条 参数1和2都是字典形式具体使用如下： 1collection.upadta_many(&#123;&apos;name&apos;:&apos;张三&apos;&#125;,&#123;&apos;$set&apos;:&#123;&apos;age&apos;:30&#125;&#125;)#将姓名为张三的人年龄全部改为30 删除删除也有两个方法 12collection.delete_one(&apos;name&apos;:&apos;张三&apos;)#把第一个name是张三的记录删除collection.delete_many(&apos;name&apos;:&apos;张三&apos;)#把name是张三的记录全部删除 删除方法只有一个参数，是字典形式。至此,mongodb以及pymongo的使用暂时结束了！ 原创文章，转载请注明出处！]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据库</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一键设置爬虫headers]]></title>
    <url>%2F2018%2F10%2F18%2F%E4%B8%80%E9%94%AE%E8%AE%BE%E7%BD%AE%E7%88%AC%E8%99%ABheaders%2F</url>
    <content type="text"><![CDATA[在写爬虫的时候我们经常需要设置headers属性来让爬虫模拟浏览器从而获得数据。在添加headers属性的时候，需要把浏览器所有的headers属性都写上去：这么长的headers如果复制下来然后手动把它设置成字典的形式太麻烦、太费时间。那么有没有办法一下把这些属性转为字典形式呢？带着这个疑问我向大佬请教：大佬不愧是大佬，分分钟解决我的问题好吧。下面介绍下这个方法：安装（输入以下命令）：pip install –upgrade git+https://github.com/kingname/CrawlerUtility.git使用：首先引入这个包然后把从浏览器复制下来的headers保存成长字符串。在使用ChromeHeaders2Dict解析一下就完事了是不是很简单！推荐：大佬的github 后记：我使用这个包的时候，是第一次使用别人手动写的第三方包，中间也遇到了很多问题。比如一开始我不知道怎么安装，然后在网上搜了一下怎么安装的资料。我这才知道安装第三方包原来有两种方式，我以前还以为只能手动下载安装呢。下面记录下两种安装方式：一、手动安装 在github上面下载包 然后解压该文件 在该文件夹按住shift+鼠标右键 在此处打开命令行窗口，然后输入python setup.py install 二、自动安装直接在命令行输入pip install 包eg:pip install pillow其实在每个github项目下都有README文件在这个文件里都会介绍怎么install，比如上面的这个项目：然后：问题又来了，在上面这些东西都弄好了之后我在pycharm上面引入的时候pycharm报错，对于我这样一个萌新来说瞬间又懵了。于是我又向大佬请教…这才知道pycharm原来还有一个加载时间，果然一小会过后，这个包就能正常使用了。不得不说，这个大佬人真的很好，身为这么大的一个大佬，对于我这个萌新的问题都很耐心的解答，再次表示感谢。这个大佬就是我最近看的一本爬虫书的作者技术过硬人又好！！！推荐去看看这本书，写的真不错，我这种死笨死笨的萌新都看的很明白！ 原创文章，转载请注明出处！]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>headers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo使用笔记]]></title>
    <url>%2F2018%2F10%2F17%2Fhexo%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[创建新文件在D:/个人博客/BLOG/source/_posts文件夹下执行命令hexo new ‘新文件名字’ 在文本中添加图片 把主页配置文件_config.yml里的post_asset_folder:这个选项设置为true(如过以后不想生成同名的文件夹了改为false即可) 在hexo目录下执行mup install hexo_asset_image –save,这是下载安装上传本地图片的插件。 等待安装完成后，再运行上面创建新文件的命令来生成新md文件时，/source/_posts文件夹中除了xxx.md文件还有一个同名的文件夹。 最后在xxx.md中想引入图片时，先把图片复制到这个文件夹中，然后只需要在xxx.md中按照markdown的格式引入图片：ps:!后面没有空格，hexo使用笔记前可加/也可以不加，图片名字一定不要写错。在页面中添加超链接关于文章推送的问题之前由于不会弄，导致每次推送时都把git上面的CNAME文件弄丢了，每次推送完之后还要重新创建CNAME文件，这样很麻烦。通过查阅资料知道了把CNAME文件放在本地hexo目录下source的_posts文件夹下就可以解决这个问题了。关于云解析首先要有一个域名，我用的是腾讯云域名：www和@主机记录的记录值是自己的githubpage的地址然后本地文件中要有一个CNAME文件，这个文件只有一行：这样就行了 原创文章，转载请注明出处！]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HELL HEXO]]></title>
    <url>%2F2018%2F10%2F17%2FHELL-HEXO%2F</url>
    <content type="text"><![CDATA[This is my BLOG]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F10%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Hello,this is my blog,i’m Yu deqiang. nice to meet you!]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
