<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python基础复习]]></title>
    <url>%2F2018%2F10%2F19%2Fpython%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[基础复习基础类型控制语句基础类型： 整数型 int 浮点数 float 字符串 str 布尔值 True、Flase 空值 None 变量 变量在计算机中不仅可以是数字，还可以是任意数据类型，变量在称剧中就是用一个变量名表示 字符串详解===转义字符:因为一些特殊字符是python中的关键字或一些特殊的概念如换行。所以以特殊字符 \ 开头，构造转义字符。常见的转义字符：\n 换行 \t 制表符\’ 单引号 \” 双引号\ 反斜杠 遍历：for i in ‘abc’: print(i)‘a’,’b’,’c’ 下标访问：‘hello’[4]→o 搜索：(了解)’字符串’.count(子字符串) 搜索子串出现次数‘xyaxyaXY’.count(‘xy’)→ 2‘xyaxyaXY’.count(‘xy’, 2)(了解)判断字符串是否以某个字母开头→ 1‘abcd’.startswith(‘a’)→ True‘abcd’.endswith(‘d’)→ True 字符串.find(子串) 找到返回下标，未找到返回-1‘axyaXY’.find(‘xy’)→ 1‘aaXY’.find(‘xy’)→ -1index()方法与find()类似，区别是未找到的时候报错。 替换 ：字符串.replace(老子串，新字符串)‘aaXY’.replace(‘aa’, ‘bb’)‘bbXY’分隔：(了解)partition把一个字符串切成几块并返回，包含子串。‘xyaxyaXY’.partition(‘xy’)(‘’, ‘xy’, ‘axyaXY’) 字符串.split(子串)，根据子串分成几部分并返回列表，不包含子串。‘xyaxyaXY’.split(‘x’)[‘’, ‘ya’, ‘yaXY’] 连接：join()用一个字符串连接可迭代对象的各个项。‘-‘.join([‘小明’, ‘hong’, ‘li’])→ ‘小明-hong-li’ 删除：字符串.strip(要删除的子串)‘今天天气真好\n’.strip(‘\n’)→ ‘今天天气真好’ 大小写转换：‘aa AA’.lower()→ ‘aa aa’‘aa AA’.upper()→ ‘AA AA’‘hello world’.capitalize()→ ‘Hello world‘aa AA’.swapcase()→ ‘AA aa’ isxxx判断:判断是否字母‘a’.isalpha()→ True判断是否空格‘ ‘.isspace()→ True判断是否数字‘1’.isdigit()→ True判断是否合法的变量名‘a4’.isidentifier()→ True 填充：对齐的时候会用到‘’.center(填充后的字符串总长度，要填充的字符串)‘abc’.center(5, ‘_’)→ ‘abc‘右侧填充‘abc’.ljust(10, ‘_’)→ ‘abc_______’左侧填充‘abc’.rjust(10, ‘_’)→ ‘___abc’ （以上了解end） 判断变量类型 type()函数 判断变量类型 isinstance(值， 类型) 如果值属于类型的话返回True 数据类型转换 int(x) 将x转换为一个整数 long(x) 将x转换为一个长整数 float(x ) 将x转换到一个浮点数 complex(real) 创建一个复数 str(x ) 将对象 x 转换为字符串 repr(x ) 将对象 x 转换为表达式字符串 eval(str ) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s ) 将序列 s 转换为一个元组 list(s ) 将序列 s 转换为一个列表 chr(x ) 将一个整数转换为一个字符 unichr(x ) 将一个整数转换为Unicode字符 ord(x ) 将一个字符转换为它的整数值 hex(x ) 将一个整数转换为一个十六进制字符串 oct(x ) 将一个整数转换为一个八进制字符串 控制语句：if else语句12345678if 条件a: 执行1elif 条件b: 执行2elif 条件c: 执行3else： 执行4 循环for循环：123打印三次字符串for i in range(1,4): print(&apos;你好 我是你爸&apos;) while 循环1234567891011121314151617181920i = 1while i&lt;4: print(&apos;你好 我是你爸&apos;) i+=1#循环中也可以加入条件控制语句i = 0while i &lt;10: i = i+1 if i %2 == 0: continue#当i是偶数时跳过此次循环 print(i)#break语句：用来结束循环i = 0while i &lt;10: i = i+1 print(i) if i == 6: break 字典列表元组列表list：定义：原来的单值变量无法满足业务需求，需求一个”容器“来装内容列表存储一些列有序（有下标）数据。容器内可以保存整数、布尔、字符串、或其他容器语法：创建一个列表：list1 = [1,’a’]还可以通过类 内置关键字创建 list1 = list() 添加项： append()方法，添加新项到列表的末尾list.append(要添加的数据) insert()方法，可以根据索引值插入制定数据。list.insert(索引，要添加的数据) for 循环 +append,批量添加项。list1 = [1,2,3,4]for i in range(5, 8): list1.append(i)print(list1) 两个列表拼接，用加号list1 = [1,2,3]list2 = [4,5,6]list3 = list1 + list2 删除项： pop()list.pop(索引)，根据索引删除列表中的某一个元素，返回删除成功的元素。pop()不传索引参数的时候，默认删除列表最后一项。pop()函数相当于append和insert函数的逆运算。 remove()list.remove(想要删除的项目值) 根据项item的值value来删除 clear()清空列表lisr.clear() 清空所有项目，返回空列表。 del删除列表对象，根据索引删除元素list = [1,2,3,4]del list[0]表示删除的是1 访问查询：通过索引（下标）list[0] 修改：修改基于索引的。访问列表下标，然后等号赋值。list [索引] = 新值 遍历：列表是一个可迭代对象，通过for循环可以吧一个列表中的元素依次取出如果判断一个对象是可迭代对象：通过collections模块的Itearable类型来判断。from collections import Iterableisinstance(‘abc’,Iterable)#判断字符串abc是否可以迭代True#返回true代表可以迭代list = [1,2,3,4]for i in list: print(i)#循环遍历出列表所有元素。 切片：列表[索引开始：索引结束：步进]切割截取出来区间。切片参数为负数是，截取方向向右为正，步进为正式才能截取。步进与截取方向相反时，结果为空索引0可以省略list[0:2] 等同于 list[:2]反向reverse输出列表list[::-1] &gt;&gt;&gt; [5, 4, 3, 2, 1] 列表生成式（不常用）12345678list1 = []for i in range(1,5) list1.append(i)#同样是在列表中加入1,2,3,4也可以用列表生成式写：[i for i in range(1,5)]#列表生成式也可以加入条件判断[i for i in range(1,10) if i%2==0]输出偶数 字典字典也是一种容器，特点：键值对存储没有索引，是无序的。靠键来增删改查 创建： 内置类实例化创建dict1 = dict() 大括号，内容空dict1 = {} 创建时附初始值dict1 = {‘name’: ‘小明’, ‘age’: 13, ‘sex’: ‘male’} 查询： （常用）dict1[键key]dict1 = {‘name’: ‘小明’, ‘age’: 13, ‘sex’: ‘male’}dict1[‘name’] &gt;&gt; ‘小明’如果键不存在的话，报 KeyError错误。dict1[‘aaa’] &gt;&gt;&gt; KeyError:aaa get(键, 默认值)跟dict[键]非常相似，只不过多了个默认值。当键不存在的时候会报Nonedict1.get(‘name’) &gt;&gt;&gt; ‘小明’dict1.get(‘aaa’, None) &gt;&gt;&gt; None 添加：dict[新建] = 新值 修改：dict[键] = 新值 遍历：先dict.items() 转换为 大列表套小列表项的形式。再用 for 循环遍历出来。for k,v in 字典.items(): print(k, v)dict.keys()吧字典中的key取出来dict.values()把字典中的value取出来 删除： 键访问，值设置为None, 键还在字典[键] = Nonedict1 = {‘name’: ‘小明’, ‘age’: 13, ‘sex’: ‘male’}dict1[‘name’] = Nonedict1[‘name’] &gt;&gt;&gt; None （常用）字典.pop(键) 根据键删除，返回删除成功的值，会把键和值都删除dict1 = {‘name’: ‘小明’, ‘age’: 13, ‘sex’: ‘male’}dict1.pop(‘name’) &gt;&gt;&gt; ‘小明’dict1 &gt;&gt;&gt; {‘age’: 13, ‘sex’: ‘male’} del 字典[键]， del关键字删除，没有返回值，会把键和值都删除 字典.clear() 删除所有内容dict1.clear()dict1 &lt;&lt;&lt; {} 其他的常用方法：dict.items() 返回一个列表，每一项是 键值对dict.keys() 返回一个列表，每一项是字典里的 键dict.values() 返回一个列表，每一项是字典里的 值dict.contains(key) 键存在的话返回True，不存在返回False 元组元组跟list非常相似，特点和区别是 “不可修改”。所以元组需要在创建的时候就指定数据。语法是小括号括起来，逗号分隔每一项 创建:tuple2 = tuple((10, 20, ‘张三’))（常用）tuple1 = (10, 20, ‘张三’)场景:元组由于不可变，适合定义 常量、配置、不需要改变的值。这样在复杂代码中就不用害怕因为bug误修改值。例如定义 中国的所有省份，一个注册登录表单中的下拉框选项 查询:有索引，通过下标访问tuple[index]tuple2 = (‘河南’, ‘云南’)tuple2[0] &gt;&gt;&gt; ‘河南’ 也支持切片:tuple2[0:1] &gt;&gt;&gt; (‘河南’,)注意的一个地方元组有时只有一项的时候，后面仍有一个逗号。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础</tag>
        <tag>复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分享一种在markdown中插入图片的新方法]]></title>
    <url>%2F2018%2F10%2F18%2F%E5%88%86%E4%BA%AB%E4%B8%80%E7%A7%8D%E5%9C%A8markdown%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E6%96%B0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言我在前面的hexo使用笔记中介绍过怎么插入图片，前面那种方法虽然能用，但还是有点麻烦，每次插入图片都要写一段markdown代码。每次创建新博客的时候都会新建一个md文件和一个文件夹，不仅麻烦而且还让博客文件夹变得不简洁。下面我介绍一种新的方法，既不用创建新的存放图片的文件夹，而且还自动生成markdown语法代码，再插入图片的时候直接ctrl+v就完事了，看起来是不是很方便呢？ 介绍下面进入正文，这种酷炫的新方法来自于大佬的git链接MarkdownPicPicker 是一个Markdown写作辅助工具。它能将剪贴板中的图片上传到网络图床中，并将markdown格式的图片链接(![]（&lt;图片地址&gt;))复制到剪贴板中。项目的readme中指明了安装使用方法下载链接下载完成后并解压，解压完成后得到一个MarkdownPicPicker.exe可执行文件和一个pic文件夹。 使用截图之后，比如我使用qq的快捷键截图，然后运行一下MarkdownPicPicker.exe，在你的编辑器中按下ctrl+v,神奇的事情就发生了，你会直接得到一段markdown插入图片的代码。是不是比上次的方法方便多了。如果你只想复制链接，不想让他变成这种形式，那么，你可以在命令行中输入markdownpicpicker.exe -linkonly 优化如果你觉得上面的方法还不够方便？是不是每次还要用鼠标来运行exe文件觉得很麻烦？没关系，还有一种方法可以优化这些步骤。官方文档说使用AutoHotKey来启动程序可以吧整个流程缩短到两秒钟 AutoHotkeyAutoHotKey是什么东西？我其实也是第一次听说这个什么软件，完全一脸懵比，上网上查了下才知道是干什么用的，在官网上下载之后然后运行出来发现是一份英文帮助文档，我也看不懂说的是什么。后面才知道这是个脚本程序，可以自定义快捷键来执行某个程序或某种命令。 ## 怎么使用呢？新建一个文本本件，名字随便起，然后把后缀名改为.ahk然后编辑这个文件输入以下代码： 1234#b::Run, D:\git第三方包和软件\MarkdownPicPicker_v1.0.0\markdownpicpicker.exeReturn!b::Run, D:\git第三方包和软件\MarkdownPicPicker_v1.0.0\markdownpicpicker.exe -linkonlyReturn 在鼠标右键点击run script即可运行。这里定义了两个快捷键，第一行代码表示按下键盘win+b键执行markdownpicpicker.exe第三行表示按下alt+b执行markdownpicpicker.exe -linkonly这和在命令行中的执行文件是一样的。关于autohotkey还有很多作用，请自行baidu,google。]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python与MongoDB]]></title>
    <url>%2F2018%2F10%2F18%2Fpython%E4%B8%8EMongoDB-1%2F</url>
    <content type="text"><![CDATA[MongoDB介绍：MongoDB是一款基于c++开发的开源文档数据库，数据在MongoDB中以Key-Value的形式存储，就像是python的字典一样。使用MongoDB的管理软件Robo3T可以实现数据库的可视化。 安装：首先下载并解压MongoDB:访问官网，从官网上下载：官网下载选择适合自己的版本和操作系统然后Download就可以了解压后把Bin下的文件辅助到新的文件夹（在c盘或者d盘创建MongoDB文件夹）并创建存储数据库的文件夹Data和日志文件夹Log并创建mongod.conf，操作完成后文件目录如下图所示：接下来就是编辑mongod.conf了使用notepad++或其他除了编辑器(除了记事本)打开mongod.conf然后将以下代码复制进去：12345678910systemLog: destination: file path: D:\MongoDB\Log\mongo.log logAppend: truestorage: dbPath: D:\MongoDB\Datanet: bindIp: 127.0.0.1security: authorization: disabled 这里的path和dppath根据设置成自己的路径，比如我的Log和Data是放在D盘MongoDB文件夹下的。然后在安装目录下启动命令行，输入：1mongod.exe --config mongod.conf 即可启动Mongodb(ps:启动后不能关闭这个窗口哦，否则mongodb服务会被关闭，还有一种方法可以将mongodb设置为windows服务启动，这样就不用每次输入命令启动啦，不过这种方法我还没有研究怎么用，等我会使用了在更新。) Robo 3T介绍Robo 3T是一个快平台的MongoDB管理工具，可以在图形界面中查询或者修改MongoDB 下载和安装访问官网下载robo3t选择Download robo3t等待安装完成后打开 使用单机create链接(如下图),如果monggodb在本地计算机上面运行，只需要在Name这一栏填一个名字就可(也可以不填使用默认名字)，单击save即可然后点击connect就可以连接MongoDB了可以看到，数据在MongoDB中是按照库(Database)——集合——文档的层级关系来存储的。文档就像是python中的一个字典，集合相当于一个包含了很多字典的列表；库相当于一个大字典，大字典里面的每一个键值对都对应了一个集合，key为集合的名字，Value就是一个集合。 PyMongo安装1pip install pymongo pymongo的使用使用pymongo初始化数据库连接12345from pymongo import MongoClientclient = MongoClient()database = client[&apos;库名&apos;]#创建一个库collection = database[&apos;集合名&apos;]#创建一个集合#这里的库名和集合名除了可以是字符串还可以是一个变量，当库名或者集合名是一个变量的时候，可以通过循环来批量操作数据库，比如要创建多个集合的时候，可以吧集合名先保存到一个列表中，然后通过循环穿件多个集合。 插入数据插入操作用到的方法为insert(参数)参数就是python的字典。 123456789101112131415from pymongo import MongoClientclient = MongoClient()database = client[&apos;Chapter6&apos;]collection = database[&apos;spider&apos;]data = &#123;&apos;id&apos;: 2, &apos;name&apos;: &apos;张三&apos;, &apos;age&apos;: 20, &apos;salary&apos;: 9999&#125;collection.insert(data)#插入一条数据#当然也可以一次插入多条数据，先把多条数据保存到一个列表中，然后直接使用insert()即可more_data = [ &#123;&apos;id&apos;: 3, &apos;name&apos;: &apos;张四&apos;, &apos;age&apos;: 20, &apos;salary&apos;: 999&#125;, &#123;&apos;id&apos;: 4, &apos;name&apos;: &apos;张五&apos;, &apos;age&apos;: 20, &apos;salary&apos;: 99&#125;, &#123;&apos;id&apos;: 5, &apos;name&apos;: &apos;张六&apos;, &apos;age&apos;: 20, &apos;salary&apos;: 9&#125;, &#123;&apos;id&apos;: 6, &apos;name&apos;: &apos;张七&apos;, &apos;age&apos;: 20, &apos;salary&apos;: 19999&#125;]collection.insert(more_data) 查找数据查找功能对应的方法是 12find(查询条件，返回字段)#返回所有符合的信息find_one(查询条件，返回字段)#返回一条符合的信息 在不写find方法参数的时候，表示获取指定集合中所有字段。返回字段的参数指定返回内容。这个参数也是一个字典，key就是字段的名称，value是0或1,0表示不返回这个字段，1表示返回这个字段。其中_id这个字段比较特殊，必须人工指定它的值为0，这样才不会返回。而对于其他数据，应该统一使用返回，或者不返回。eg: 1collection.find(&#123;&apos;age&apos;:20&#125;,&#123;&apos;_id&apos;:0&#125;)#查询所有age为20的记录，返回除了_id的所有字段 这里需要知道：find()方法返回的是一个pymongo对象，这个对象可以被for循环展开，展开之后可以得到很多个字典。pymongo也支持逻辑查询：它们对应的关键词如下所示： $gt great than 大于 $lt less than 小于 $gte Greater than equal to 大于等于 $lte less than equal to 小于等于 $eq equal to 等于 $ne not equal to 不等于eg: 12collection.find(&apos;age&apos;:&#123;&apos;$gt&apos;:19&#125;)#查询age&gt;19的记录collection.find(&apos;age&apos;:&#123;&apos;$gte&apos;:19,&apos;$lt&apos;:30&#125;)#查询19≤age&lt;30的记录 对查询结果进行排序排序的方法为sort(),这个方法一般和find()配合使用他有两个参数，第一个参数指明以那一项进行排序，第二个参数为1或者-1，1表示升序，-1表示降序。eg: 1collection.find(&apos;age&apos;:&#123;&apos;$gt&apos;:19&#125;).sort(&apos;age&apos;,-1)#查询所有age大于19并以age按照降序进行排序。 修改修改也有两个方法： 12collection.updata_one(参数1，参数2)#修改一条collection.updata_many(参数1，参数2)#修改多条 参数1和2都是字典形式具体使用如下： 1collection.upadta_many(&#123;&apos;name&apos;:&apos;张三&apos;&#125;,&#123;&apos;$set&apos;:&#123;&apos;age&apos;:30&#125;&#125;)#将姓名为张三的人年龄全部改为30 删除删除也有两个方法 12collection.delete_one(&apos;name&apos;:&apos;张三&apos;)#把第一个name是张三的记录删除collection.delete_many(&apos;name&apos;:&apos;张三&apos;)#把name是张三的记录全部删除 删除方法只有一个参数，是字典形式。至此,mongodb以及pymongo的使用暂时结束了！]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据库</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一键设置爬虫headers]]></title>
    <url>%2F2018%2F10%2F18%2F%E4%B8%80%E9%94%AE%E8%AE%BE%E7%BD%AE%E7%88%AC%E8%99%ABheaders%2F</url>
    <content type="text"><![CDATA[在写爬虫的时候我们经常需要设置headers属性来让爬虫模拟浏览器从而获得数据。在添加headers属性的时候，需要把浏览器所有的headers属性都写上去：这么长的headers如果复制下来然后手动把它设置成字典的形式太麻烦、太费时间。那么有没有办法一下把这些属性转为字典形式呢？带着这个疑问我向大佬请教：大佬不愧是大佬，分分钟解决我的问题好吧。下面介绍下这个方法：安装（输入以下命令）：pip install –upgrade git+https://github.com/kingname/CrawlerUtility.git使用：首先引入这个包然后把从浏览器复制下来的headers保存成长字符串。在使用ChromeHeaders2Dict解析一下就完事了是不是很简单！推荐：大佬的github 后记：我使用这个包的时候，是第一次使用别人手动写的第三方包，中间也遇到了很多问题。比如一开始我不知道怎么安装，然后在网上搜了一下怎么安装的资料。我这才知道安装第三方包原来有两种方式，我以前还以为只能手动下载安装呢。下面记录下两种安装方式：一、手动安装 在github上面下载包 然后解压该文件 在该文件夹按住shift+鼠标右键 在此处打开命令行窗口，然后输入python setup.py install 二、自动安装直接在命令行输入pip install 包eg:pip install pillow其实在每个github项目下都有README文件在这个文件里都会介绍怎么install，比如上面的这个项目：然后：问题又来了，在上面这些东西都弄好了之后我在pycharm上面引入的时候pycharm报错，对于我这样一个萌新来说瞬间又懵了。于是我又向大佬请教…这才知道pycharm原来还有一个加载时间，果然一小会过后，这个包就能正常使用了。不得不说，这个大佬人真的很好，身为这么大的一个大佬，对于我这个萌新的问题都很耐心的解答，再次表示感谢。这个大佬就是我最近看的一本爬虫书的作者技术过硬人又好！！！推荐去看看这本书，写的真不错，我这种死笨死笨的萌新都看的很明白！]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>headers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo使用笔记]]></title>
    <url>%2F2018%2F10%2F17%2Fhexo%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[创建新文件在D:/个人博客/BLOG/source/_posts文件夹下执行命令hexo new ‘新文件名字’ 在文本中添加图片 把主页配置文件_config.yml里的post_asset_folder:这个选项设置为true(如过以后不想生成同名的文件夹了改为false即可) 在hexo目录下执行mup install hexo_asset_image –save,这是下载安装上传本地图片的插件。 等待安装完成后，再运行上面创建新文件的命令来生成新md文件时，/source/_posts文件夹中除了xxx.md文件还有一个同名的文件夹。 最后在xxx.md中想引入图片时，先把图片复制到这个文件夹中，然后只需要在xxx.md中按照markdown的格式引入图片：ps:!后面没有空格，hexo使用笔记前可加/也可以不加，图片名字一定不要写错。在页面中添加超链接关于文章推送的问题之前由于不会弄，导致每次推送时都把git上面的CNAME文件弄丢了，每次推送完之后还要重新创建CNAME文件，这样很麻烦。通过查阅资料知道了把CNAME文件放在本地hexo目录下source的_posts文件夹下就可以解决这个问题了。关于云解析首先要有一个域名，我用的是腾讯云域名：www和@主机记录的记录值是自己的githubpage的地址然后本地文件中要有一个CNAME文件，这个文件只有一行：这样就行了]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HELL HEXO]]></title>
    <url>%2F2018%2F10%2F17%2FHELL-HEXO%2F</url>
    <content type="text"><![CDATA[This is my BLOG]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F10%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Hello,this is my blog,i’m Yu deqiang. nice to meet you!]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
